//**********************************************************************`
//* This is an include file generated by Message Compiler.             *`
//*                                                                    *`
//* Copyright (c) Microsoft Corporation. All Rights Reserved.          *`
//**********************************************************************`
#pragma once

//*****************************************************************************
//
// Notes on the ETW event code generated by MC:
//
// - Structures and arrays of structures are treated as an opaque binary blob.
//   The caller is responsible for packing the data for the structure into a
//   single region of memory, with no padding between values. The macro will
//   have an extra parameter for the length of the blob.
// - Arrays of nul-terminated strings must be packed by the caller into a
//   single binary blob containing the correct number of strings, with a nul
//   after each string. The size of the blob is specified in characters, and
//   includes the final nul.
// - Arrays of SID are treated as a single binary blob. The caller is
//   responsible for packing the SID values into a single region of memory with
//   no padding.
// - The length attribute on the data element in the manifest is significant
//   for values with intype win:UnicodeString, win:AnsiString, or win:Binary.
//   The length attribute must be specified for win:Binary, and is optional for
//   win:UnicodeString and win:AnsiString (if no length is given, the strings
//   are assumed to be nul-terminated). For win:UnicodeString, the length is
//   measured in characters, not bytes.
// - For an array of win:UnicodeString, win:AnsiString, or win:Binary, the
//   length attribute applies to every value in the array, so every value in
//   the array must have the same length. The values in the array are provided
//   to the macro via a single pointer -- the caller is responsible for packing
//   all of the values into a single region of memory with no padding between
//   values.
// - Values of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary can be generated and collected on Vista or later.
//   However, they may not decode properly without the Windows 10 2018 Fall
//   Update.
// - Arrays of type win:CountedUnicodeString, win:CountedAnsiString, and
//   win:CountedBinary must be packed by the caller into a single region of
//   memory. The format for each item is a UINT16 byte-count followed by that
//   many bytes of data. When providing the array to the generated macro, you
//   must provide the total size of the packed array data, including the UINT16
//   sizes for each item. In the case of win:CountedUnicodeString, the data
//   size is specified in WCHAR (16-bit) units. In the case of
//   win:CountedAnsiString and win:CountedBinary, the data size is specified in
//   bytes.
//
//*****************************************************************************

#include <wmistr.h>
#include <evntrace.h>
#include <evntprov.h>
#include "../JonMon/jtime.h"

#ifndef ETW_INLINE
  #ifdef _ETW_KM_
    // In kernel mode, save stack space by never inlining templates.
    #define ETW_INLINE DECLSPEC_NOINLINE __inline
  #else
    // In user mode, save code size by inlining templates as appropriate.
    #define ETW_INLINE __inline
  #endif
#endif // ETW_INLINE

#if defined(__cplusplus)
extern "C" {
#endif

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_USE_KERNEL_MODE_APIS macro:
// Controls whether the generated code uses kernel-mode or user-mode APIs.
// - Set to 0 to use Windows user-mode APIs such as EventRegister.
// - Set to 1 to use Windows kernel-mode APIs such as EtwRegister.
// Default is based on whether the _ETW_KM_ macro is defined (i.e. by wdm.h).
// Note that the APIs can also be overridden directly, e.g. by setting the
// MCGEN_EVENTWRITETRANSFER or MCGEN_EVENTREGISTER macros.
//
#ifndef MCGEN_USE_KERNEL_MODE_APIS
  #ifdef _ETW_KM_
    #define MCGEN_USE_KERNEL_MODE_APIS 1
  #else
    #define MCGEN_USE_KERNEL_MODE_APIS 0
  #endif
#endif // MCGEN_USE_KERNEL_MODE_APIS

//
// MCGEN_HAVE_EVENTSETINFORMATION macro:
// Controls how McGenEventSetInformation uses the EventSetInformation API.
// - Set to 0 to disable the use of EventSetInformation
//   (McGenEventSetInformation will always return an error).
// - Set to 1 to directly invoke MCGEN_EVENTSETINFORMATION.
// - Set to 2 to to locate EventSetInformation at runtime via GetProcAddress
//   (user-mode) or MmGetSystemRoutineAddress (kernel-mode).
// Default is determined as follows:
// - If MCGEN_EVENTSETINFORMATION has been customized, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else if the target OS version has EventSetInformation, set to 1
//   (i.e. use MCGEN_EVENTSETINFORMATION).
// - Else set to 2 (i.e. try to dynamically locate EventSetInformation).
// Note that an McGenEventSetInformation function will only be generated if one
// or more provider in a manifest has provider traits.
//
#ifndef MCGEN_HAVE_EVENTSETINFORMATION
  #ifdef MCGEN_EVENTSETINFORMATION             // if MCGEN_EVENTSETINFORMATION has been customized,
    #define MCGEN_HAVE_EVENTSETINFORMATION   1 //   directly invoke MCGEN_EVENTSETINFORMATION(...).
  #elif MCGEN_USE_KERNEL_MODE_APIS             // else if using kernel-mode APIs,
    #if NTDDI_VERSION >= 0x06040000            //   if target OS is Windows 10 or later,
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EtwSetInformation" via MmGetSystemRoutineAddress.
    #endif                                     // else (using user-mode APIs)
  #else                                        //   if target OS and SDK is Windows 8 or later,
    #if WINVER >= 0x0602 && defined(EVENT_FILTER_TYPE_SCHEMATIZED)
      #define MCGEN_HAVE_EVENTSETINFORMATION 1 //     directly invoke MCGEN_EVENTSETINFORMATION(...).
    #else                                      //   else
      #define MCGEN_HAVE_EVENTSETINFORMATION 2 //     find "EventSetInformation" via GetModuleHandleExW/GetProcAddress.
    #endif
  #endif
#endif // MCGEN_HAVE_EVENTSETINFORMATION

//
// MCGEN Override Macros
//
// The following override macros may be defined before including this header
// to control the APIs used by this header:
//
// - MCGEN_EVENTREGISTER
// - MCGEN_EVENTUNREGISTER
// - MCGEN_EVENTSETINFORMATION
// - MCGEN_EVENTWRITETRANSFER
//
// If the the macro is undefined, the MC implementation will default to the
// corresponding ETW APIs. For example, if the MCGEN_EVENTREGISTER macro is
// undefined, the EventRegister[MyProviderName] macro will use EventRegister
// in user mode and will use EtwRegister in kernel mode.
//
// To prevent issues from conflicting definitions of these macros, the value
// of the override macro will be used as a suffix in certain internal function
// names. Because of this, the override macros must follow certain rules:
//
// - The macro must be defined before any MC-generated header is included and
//   must not be undefined or redefined after any MC-generated header is
//   included. Different translation units (i.e. different .c or .cpp files)
//   may set the macros to different values, but within a translation unit
//   (within a single .c or .cpp file), the macro must be set once and not
//   changed.
// - The override must be an object-like macro, not a function-like macro
//   (i.e. the override macro must not have a parameter list).
// - The override macro's value must be a simple identifier, i.e. must be
//   something that starts with a letter or '_' and contains only letters,
//   numbers, and '_' characters.
// - If the override macro's value is the name of a second object-like macro,
//   the second object-like macro must follow the same rules. (The override
//   macro's value can also be the name of a function-like macro, in which
//   case the function-like macro does not need to follow the same rules.)
//
// For example, the following will cause compile errors:
//
//   #define MCGEN_EVENTWRITETRANSFER MyNamespace::MyClass::MyFunction // Value has non-identifier characters (colon).
//   #define MCGEN_EVENTWRITETRANSFER GetEventWriteFunctionPointer(7)  // Value has non-identifier characters (parentheses).
//   #define MCGEN_EVENTWRITETRANSFER(h,e,a,r,c,d) EventWrite(h,e,c,d) // Override is defined as a function-like macro.
//   #define MY_OBJECT_LIKE_MACRO     MyNamespace::MyClass::MyEventWriteFunction
//   #define MCGEN_EVENTWRITETRANSFER MY_OBJECT_LIKE_MACRO // Evaluates to something with non-identifier characters (colon).
//
// The following would be ok:
//
//   #define MCGEN_EVENTWRITETRANSFER  MyEventWriteFunction1  // OK, suffix will be "MyEventWriteFunction1".
//   #define MY_OBJECT_LIKE_MACRO      MyEventWriteFunction2
//   #define MCGEN_EVENTWRITETRANSFER  MY_OBJECT_LIKE_MACRO   // OK, suffix will be "MyEventWriteFunction2".
//   #define MY_FUNCTION_LIKE_MACRO(h,e,a,r,c,d) MyNamespace::MyClass::MyEventWriteFunction3(h,e,c,d)
//   #define MCGEN_EVENTWRITETRANSFER  MY_FUNCTION_LIKE_MACRO // OK, suffix will be "MY_FUNCTION_LIKE_MACRO".
//
#ifndef MCGEN_EVENTREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTREGISTER        EtwRegister
  #else
    #define MCGEN_EVENTREGISTER        EventRegister
  #endif
#endif // MCGEN_EVENTREGISTER
#ifndef MCGEN_EVENTUNREGISTER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTUNREGISTER      EtwUnregister
  #else
    #define MCGEN_EVENTUNREGISTER      EventUnregister
  #endif
#endif // MCGEN_EVENTUNREGISTER
#ifndef MCGEN_EVENTSETINFORMATION
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTSETINFORMATION  EtwSetInformation
  #else
    #define MCGEN_EVENTSETINFORMATION  EventSetInformation
  #endif
#endif // MCGEN_EVENTSETINFORMATION
#ifndef MCGEN_EVENTWRITETRANSFER
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define MCGEN_EVENTWRITETRANSFER   EtwWriteTransfer
  #else
    #define MCGEN_EVENTWRITETRANSFER   EventWriteTransfer
  #endif
#endif // MCGEN_EVENTWRITETRANSFER

//
// MCGEN_EVENT_ENABLED macro:
// Override to control how the EventWrite[EventName] macros determine whether
// an event is enabled. The default behavior is for EventWrite[EventName] to
// use the EventEnabled[EventName] macros.
//
#ifndef MCGEN_EVENT_ENABLED
#define MCGEN_EVENT_ENABLED(EventName) EventEnabled##EventName()
#endif

//
// MCGEN_EVENT_ENABLED_FORCONTEXT macro:
// Override to control how the EventWrite[EventName]_ForContext macros
// determine whether an event is enabled. The default behavior is for
// EventWrite[EventName]_ForContext to use the
// EventEnabled[EventName]_ForContext macros.
//
#ifndef MCGEN_EVENT_ENABLED_FORCONTEXT
#define MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, EventName) EventEnabled##EventName##_ForContext(pContext)
#endif

//
// MCGEN_ENABLE_CHECK macro:
// Determines whether the specified event would be considered as enabled
// based on the state of the specified context. Slightly faster than calling
// McGenEventEnabled directly.
//
#ifndef MCGEN_ENABLE_CHECK
#define MCGEN_ENABLE_CHECK(Context, Descriptor) (Context.IsEnabled && McGenEventEnabled(&Context, &Descriptor))
#endif

#if !defined(MCGEN_TRACE_CONTEXT_DEF)
#define MCGEN_TRACE_CONTEXT_DEF
// This structure is for use by MC-generated code and should not be used directly.
typedef struct _MCGEN_TRACE_CONTEXT
{
    TRACEHANDLE            RegistrationHandle;
    TRACEHANDLE            Logger;      // Used as pointer to provider traits.
    ULONGLONG              MatchAnyKeyword;
    ULONGLONG              MatchAllKeyword;
    ULONG                  Flags;
    ULONG                  IsEnabled;
    UCHAR                  Level;
    UCHAR                  Reserve;
    USHORT                 EnableBitsCount;
    PULONG                 EnableBitMask;
    const ULONGLONG*       EnableKeyWords;
    const UCHAR*           EnableLevel;
} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;
#endif // MCGEN_TRACE_CONTEXT_DEF

#if !defined(MCGEN_LEVEL_KEYWORD_ENABLED_DEF)
#define MCGEN_LEVEL_KEYWORD_ENABLED_DEF
//
// Determines whether an event with a given Level and Keyword would be
// considered as enabled based on the state of the specified context.
// Note that you may want to use MCGEN_ENABLE_CHECK instead of calling this
// function directly.
//
FORCEINLINE
BOOLEAN
McGenLevelKeywordEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ UCHAR Level,
    _In_ ULONGLONG Keyword
    )
{
    //
    // Check if the event Level is lower than the level at which
    // the channel is enabled.
    // If the event Level is 0 or the channel is enabled at level 0,
    // all levels are enabled.
    //

    if ((Level <= EnableInfo->Level) || // This also covers the case of Level == 0.
        (EnableInfo->Level == 0)) {

        //
        // Check if Keyword is enabled
        //

        if ((Keyword == (ULONGLONG)0) ||
            ((Keyword & EnableInfo->MatchAnyKeyword) &&
             ((Keyword & EnableInfo->MatchAllKeyword) == EnableInfo->MatchAllKeyword))) {
            return TRUE;
        }
    }

    return FALSE;
}
#endif // MCGEN_LEVEL_KEYWORD_ENABLED_DEF

#if !defined(MCGEN_EVENT_ENABLED_DEF)
#define MCGEN_EVENT_ENABLED_DEF
//
// Determines whether the specified event would be considered as enabled based
// on the state of the specified context. Note that you may want to use
// MCGEN_ENABLE_CHECK instead of calling this function directly.
//
FORCEINLINE
BOOLEAN
McGenEventEnabled(
    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
    _In_ PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    return McGenLevelKeywordEnabled(EnableInfo, EventDescriptor->Level, EventDescriptor->Keyword);
}
#endif // MCGEN_EVENT_ENABLED_DEF

#if !defined(MCGEN_CONTROL_CALLBACK)
#define MCGEN_CONTROL_CALLBACK

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
VOID
__stdcall
McGenControlCallbackV2(
    _In_ LPCGUID SourceId,
    _In_ ULONG ControlCode,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ PEVENT_FILTER_DESCRIPTOR FilterData,
    _Inout_opt_ PVOID CallbackContext
    )
/*++

Routine Description:

    This is the notification callback for Windows Vista and later.

Arguments:

    SourceId - The GUID that identifies the session that enabled the provider.

    ControlCode - The parameter indicates whether the provider
                  is being enabled or disabled.

    Level - The level at which the event is enabled.

    MatchAnyKeyword - The bitmask of keywords that the provider uses to
                      determine the category of events that it writes.

    MatchAllKeyword - This bitmask additionally restricts the category
                      of events that the provider writes.

    FilterData - The provider-defined data.

    CallbackContext - The context of the callback that is defined when the provider
                      called EtwRegister to register itself.

Remarks:

    ETW calls this function to notify provider of enable/disable

--*/
{
    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)CallbackContext;
    ULONG Ix;
#ifndef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(FilterData);
#endif

    if (Ctx == NULL) {
        return;
    }

    switch (ControlCode) {

        case EVENT_CONTROL_CODE_ENABLE_PROVIDER:
            Ctx->Level = Level;
            Ctx->MatchAnyKeyword = MatchAnyKeyword;
            Ctx->MatchAllKeyword = MatchAllKeyword;
            Ctx->IsEnabled = EVENT_CONTROL_CODE_ENABLE_PROVIDER;

            for (Ix = 0; Ix < Ctx->EnableBitsCount; Ix += 1) {
                if (McGenLevelKeywordEnabled(Ctx, Ctx->EnableLevel[Ix], Ctx->EnableKeyWords[Ix]) != FALSE) {
                    Ctx->EnableBitMask[Ix >> 5] |= (1 << (Ix % 32));
                } else {
                    Ctx->EnableBitMask[Ix >> 5] &= ~(1 << (Ix % 32));
                }
            }
            break;

        case EVENT_CONTROL_CODE_DISABLE_PROVIDER:
            Ctx->IsEnabled = EVENT_CONTROL_CODE_DISABLE_PROVIDER;
            Ctx->Level = 0;
            Ctx->MatchAnyKeyword = 0;
            Ctx->MatchAllKeyword = 0;
            if (Ctx->EnableBitsCount > 0) {
#pragma warning(suppress: 26451) // Arithmetic overflow cannot occur, no matter the value of EnableBitCount
                RtlZeroMemory(Ctx->EnableBitMask, (((Ctx->EnableBitsCount - 1) / 32) + 1) * sizeof(ULONG));
            }
            break;

        default:
            break;
    }

#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    //
    // Call user defined callback
    //
    MCGEN_PRIVATE_ENABLE_CALLBACK_V2(
        SourceId,
        ControlCode,
        Level,
        MatchAnyKeyword,
        MatchAllKeyword,
        FilterData,
        CallbackContext
        );
#endif // MCGEN_PRIVATE_ENABLE_CALLBACK_V2

    return;
}

#endif // MCGEN_CONTROL_CALLBACK

#ifndef _mcgen_PENABLECALLBACK
  #if MCGEN_USE_KERNEL_MODE_APIS
    #define _mcgen_PENABLECALLBACK      PETWENABLECALLBACK
  #else
    #define _mcgen_PENABLECALLBACK      PENABLECALLBACK
  #endif
#endif // _mcgen_PENABLECALLBACK

#if !defined(_mcgen_PASTE2)
// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_PASTE2(a, b) _mcgen_PASTE2_imp(a, b)
#define _mcgen_PASTE2_imp(a, b) a##b
#endif // _mcgen_PASTE2

#if !defined(_mcgen_PASTE3)
// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_PASTE3(a, b, c) _mcgen_PASTE3_imp(a, b, c)
#define _mcgen_PASTE3_imp(a, b, c) a##b##_##c
#endif // _mcgen_PASTE3

//
// Macro validation
//

// Validate MCGEN_EVENTREGISTER:

// Trigger an error if MCGEN_EVENTREGISTER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTREGISTER);

// Trigger an error if MCGEN_EVENTREGISTER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTREGISTER)
    MCGEN_EVENTREGISTER_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTREGISTER is defined as a function-like macro:
typedef void MCGEN_EVENTREGISTER_must_not_be_a_functionLike_macro_MCGEN_EVENTREGISTER;
typedef int _mcgen_PASTE2(MCGEN_EVENTREGISTER_must_not_be_a_functionLike_macro_, MCGEN_EVENTREGISTER);

// Validate MCGEN_EVENTUNREGISTER:

// Trigger an error if MCGEN_EVENTUNREGISTER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTUNREGISTER);

// Trigger an error if MCGEN_EVENTUNREGISTER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTUNREGISTER)
    MCGEN_EVENTUNREGISTER_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTUNREGISTER is defined as a function-like macro:
typedef void MCGEN_EVENTUNREGISTER_must_not_be_a_functionLike_macro_MCGEN_EVENTUNREGISTER;
typedef int _mcgen_PASTE2(MCGEN_EVENTUNREGISTER_must_not_be_a_functionLike_macro_, MCGEN_EVENTUNREGISTER);

// Validate MCGEN_EVENTSETINFORMATION:

// Trigger an error if MCGEN_EVENTSETINFORMATION is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTSETINFORMATION);

// Trigger an error if MCGEN_EVENTSETINFORMATION is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTSETINFORMATION)
    MCGEN_EVENTSETINFORMATION_must_not_be_redefined_between_headers;

// Trigger an error if MCGEN_EVENTSETINFORMATION is defined as a function-like macro:
typedef void MCGEN_EVENTSETINFORMATION_must_not_be_a_functionLike_macro_MCGEN_EVENTSETINFORMATION;
typedef int _mcgen_PASTE2(MCGEN_EVENTSETINFORMATION_must_not_be_a_functionLike_macro_, MCGEN_EVENTSETINFORMATION);

// Validate MCGEN_EVENTWRITETRANSFER:

// Trigger an error if MCGEN_EVENTWRITETRANSFER is not an unqualified (simple) identifier:
struct _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTWRITETRANSFER);

// Trigger an error if MCGEN_EVENTWRITETRANSFER is redefined:
typedef struct _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_definition_must_be_an_unqualified_identifier_, MCGEN_EVENTWRITETRANSFER)
    MCGEN_EVENTWRITETRANSFER_must_not_be_redefined_between_headers;;

// Trigger an error if MCGEN_EVENTWRITETRANSFER is defined as a function-like macro:
typedef void MCGEN_EVENTWRITETRANSFER_must_not_be_a_functionLike_macro_MCGEN_EVENTWRITETRANSFER;
typedef int _mcgen_PASTE2(MCGEN_EVENTWRITETRANSFER_must_not_be_a_functionLike_macro_, MCGEN_EVENTWRITETRANSFER);

#ifndef McGenEventWrite_def
#define McGenEventWrite_def

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventWrite _mcgen_PASTE2(McGenEventWrite_, MCGEN_EVENTWRITETRANSFER)

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventWrite(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ LPCGUID ActivityId,
    _In_range_(1, 128) ULONG EventDataCount,
    _Pre_cap_(EventDataCount) EVENT_DATA_DESCRIPTOR* EventData
    )
{
    const USHORT UNALIGNED* Traits;

    // Some customized MCGEN_EVENTWRITETRANSFER macros might ignore ActivityId.
    UNREFERENCED_PARAMETER(ActivityId);

    Traits = (const USHORT UNALIGNED*)(UINT_PTR)Context->Logger;

    if (Traits == NULL) {
        EventData[0].Ptr = 0;
        EventData[0].Size = 0;
        EventData[0].Reserved = 0;
    } else {
        EventData[0].Ptr = (ULONG_PTR)Traits;
        EventData[0].Size = *Traits;
        EventData[0].Reserved = 2; // EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA
    }

    return MCGEN_EVENTWRITETRANSFER(
        Context->RegistrationHandle,
        Descriptor,
        ActivityId,
        NULL,
        EventDataCount,
        EventData);
}
#endif // McGenEventWrite_def

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventRegister _mcgen_PASTE2(McGenEventRegister_, MCGEN_EVENTREGISTER)

#pragma warning(push)
#pragma warning(disable:6103)
// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ _mcgen_PENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Inout_ PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function registers the provider with ETW.

Arguments:

    ProviderId - Provider ID to register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for the callback.

    RegHandle - Pointer to registration handle.

Remarks:

    Should not be called if the provider is already registered (i.e. should not
    be called if *RegHandle != 0). Repeatedly registering a provider is a bug
    and may indicate a race condition. However, for compatibility with previous
    behavior, this function will return SUCCESS in this case.

--*/
{
    ULONG Error;

    if (*RegHandle != 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTREGISTER(ProviderId, EnableCallback, CallbackContext, RegHandle);
    }

    return Error;
}
#pragma warning(pop)

// This macro is for use by MC-generated code and should not be used directly.
#define McGenEventUnregister _mcgen_PASTE2(McGenEventUnregister_, MCGEN_EVENTUNREGISTER)

// This function is for use by MC-generated code and should not be used directly.
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(_Inout_ PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW and set *RegHandle = 0.

Arguments:

    RegHandle - the pointer to the provider registration handle

Remarks:

    If provider has not been registered (i.e. if *RegHandle == 0),
    return SUCCESS. It is safe to call McGenEventUnregister even if the
    call to McGenEventRegister returned an error.

--*/
{
    ULONG Error;

    if(*RegHandle == 0)
    {
        Error = 0; // ERROR_SUCCESS
    }
    else
    {
        Error = MCGEN_EVENTUNREGISTER(*RegHandle);
        *RegHandle = (REGHANDLE)0;
    }

    return Error;
}

#endif // McGenEventRegisterUnregister

#ifndef _mcgen_EVENT_BIT_SET
  #if defined(_M_IX86) || defined(_M_X64)
    // This macro is for use by MC-generated code and should not be used directly.
    #define _mcgen_EVENT_BIT_SET(EnableBits, BitPosition) ((((const unsigned char*)EnableBits)[BitPosition >> 3] & (1u << (BitPosition & 7))) != 0)
  #else // CPU type
    // This macro is for use by MC-generated code and should not be used directly.
    #define _mcgen_EVENT_BIT_SET(EnableBits, BitPosition) ((EnableBits[BitPosition >> 5] & (1u << (BitPosition & 31))) != 0)
  #endif // CPU type
#endif // _mcgen_EVENT_BIT_SET

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Provider "JonMon" event count 32
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Provider GUID = d8909c24-5be9-4502-98ca-ab7bdc24899d
EXTERN_C __declspec(selectany) const GUID JonMonProvider = {0xd8909c24, 0x5be9, 0x4502, {0x98, 0xca, 0xab, 0x7b, 0xdc, 0x24, 0x89, 0x9d}};

#ifndef JonMonProvider_Traits
#define JonMonProvider_Traits NULL
#endif // JonMonProvider_Traits

//
// Channel
//
#define JonMonProvider_CHANNEL_JonMon 0x10
#define JonMonProvider_CHANNEL_JonMon_KEYWORD 0x8000000000000000

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ProcessCreation = {0x1, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define ProcessCreation_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ProcessAccess = {0x2, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define ProcessAccess_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ProcessAccessDuplicated = {0x3, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define ProcessAccessDuplicated_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ImageLoaded = {0x4, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define ImageLoaded_value 0x4
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RegistryCreateKey = {0x5, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define RegistryCreateKey_value 0x5
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RegistryDeleteKey = {0x6, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define RegistryDeleteKey_value 0x6
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RegistrySetValue = {0x7, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define RegistrySetValue_value 0x7
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ProcessReparenting = {0x8, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define ProcessReparenting_value 0x8
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ProcessTerminate = {0x9, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define ProcessTerminate_value 0x9
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FileRename = {0xa, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define FileRename_value 0xa
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RPCClientCall = {0xb, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define RPCClientCall_value 0xb
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RPCServerCall = {0xc, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define RPCServerCall_value 0xc
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR NetworkConnectionAccepted = {0xd, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define NetworkConnectionAccepted_value 0xd
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RegistrySaveKey = {0xe, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define RegistrySaveKey_value 0xe
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DotNetLoad = {0xf, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define DotNetLoad_value 0xf
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR AMSI = {0x10, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define AMSI_value 0x10
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ImpersonationAction = {0x11, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define ImpersonationAction_value 0x11
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR RemoteThreadCreation = {0x12, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define RemoteThreadCreation_value 0x12
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SchedTaskCreation = {0x13, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define SchedTaskCreation_value 0x13
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR SchedTaskStarted = {0x14, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define SchedTaskStarted_value 0x14
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FileCreate = {0x15, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define FileCreate_value 0x15
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR FileDelete = {0x16, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define FileDelete_value 0x16
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR NamedPipeCreate = {0x17, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define NamedPipeCreate_value 0x17
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR NamedPipeOpen = {0x18, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define NamedPipeOpen_value 0x18
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WMIFilterToConsumerBinding = {0x19, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define WMIFilterToConsumerBinding_value 0x19
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TIQueueUserAPCEvent = {0x1a, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define TIQueueUserAPCEvent_value 0x1a
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DriverLoad = {0x1b, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define DriverLoad_value 0x1b
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DPAPI = {0x1c, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define DPAPI_value 0x1c
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TIWriteProcessMemory = {0x1d, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define TIWriteProcessMemory_value 0x1d
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TIReadProcessMemory = {0x1e, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define TIReadProcessMemory_value 0x1e
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ThreadTokenImpersonation = {0x1f, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define ThreadTokenImpersonation_value 0x1f
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TIRemoteAllocateVirtualMemory = {0x20, 0x0, 0x10, 0x4, 0x0, 0x0, 0x8000000000000000};
#define TIRemoteAllocateVirtualMemory_value 0x20

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Event Enablement Bits
// These variables are for use by MC-generated code and should not be used directly.
//
EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG JonMonEnableBits[1];
EXTERN_C __declspec(selectany) const ULONGLONG JonMonKeywords[1] = {0x8000000000000000};
EXTERN_C __declspec(selectany) const unsigned char JonMonLevels[1] = {4};

//
// Provider context
//
EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT JonMonProvider_Context = {0, (ULONG_PTR)JonMonProvider_Traits, 0, 0, 0, 0, 0, 0, 1, JonMonEnableBits, JonMonKeywords, JonMonLevels};

//
// Provider REGHANDLE
//
#define JonMonHandle (JonMonProvider_Context.RegistrationHandle)

//
// This macro is set to 1, indicating that the EventWrite[Name] macros
// have an Activity parameter. This is controlled by the -km and -um options.
//
#define JonMonProvider_EventWriteActivity 1

//
// Register with ETW using the control GUID specified in the manifest.
// Invoke this macro during module initialization (i.e. program startup,
// DLL process attach, or driver load) to initialize the provider.
// Note that if this function returns an error, the error means that
// will not work, but no action needs to be taken -- even if EventRegister
// returns an error, it is generally safe to use EventWrite and
// EventUnregister macros (they will be no-ops if EventRegister failed).
//
#ifndef EventRegisterJonMon
#define EventRegisterJonMon() McGenEventRegister(&JonMonProvider, McGenControlCallbackV2, &JonMonProvider_Context, &JonMonHandle)
#endif

//
// Register with ETW using a specific control GUID (i.e. a GUID other than what
// is specified in the manifest). Advanced scenarios only.
//
#ifndef EventRegisterByGuidJonMon
#define EventRegisterByGuidJonMon(Guid) McGenEventRegister(&(Guid), McGenControlCallbackV2, &JonMonProvider_Context, &JonMonHandle)
#endif

//
// Unregister with ETW and close the provider.
// Invoke this macro during module shutdown (i.e. program exit, DLL process
// detach, or driver unload) to unregister the provider.
// Note that you MUST call EventUnregister before DLL or driver unload
// (not optional): failure to unregister a provider before DLL or driver unload
// will result in crashes.
//
#ifndef EventUnregisterJonMon
#define EventUnregisterJonMon() McGenEventUnregister(&JonMonHandle)
#endif

//
// MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION macro:
// Define this macro to enable support for caller-allocated provider context.
//
#ifdef MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Advanced scenarios: Caller-allocated provider context.
// Use when multiple differently-configured provider handles are needed,
// e.g. for container-aware drivers, one context per container.
//
// Usage:
//
// - Caller enables the feature before including this header, e.g.
//   #define MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION 1
// - Caller allocates memory, e.g. pContext = malloc(sizeof(McGenContext_JonMon));
// - Caller registers the provider, e.g. EventRegisterJonMon_ForContext(pContext);
// - Caller writes events, e.g. EventWriteMyEvent_ForContext(pContext, ...);
// - Caller unregisters, e.g. EventUnregisterJonMon_ForContext(pContext);
// - Caller frees memory, e.g. free(pContext);
//

typedef struct tagMcGenContext_JonMon {
    // The fields of this structure are subject to change and should
    // not be accessed directly. To access the provider's REGHANDLE,
    // use JonMonHandle_ForContext(pContext).
    MCGEN_TRACE_CONTEXT Context;
    ULONG EnableBits[1];
} McGenContext_JonMon;

#define EventRegisterJonMon_ForContext(pContext)             _mcgen_PASTE2(_mcgen_RegisterForContext_JonMon_, MCGEN_EVENTREGISTER)(&JonMonProvider, pContext)
#define EventRegisterByGuidJonMon_ForContext(Guid, pContext) _mcgen_PASTE2(_mcgen_RegisterForContext_JonMon_, MCGEN_EVENTREGISTER)(&(Guid), pContext)
#define EventUnregisterJonMon_ForContext(pContext)           McGenEventUnregister(&(pContext)->Context.RegistrationHandle)

//
// Provider REGHANDLE for caller-allocated context.
//
#define JonMonHandle_ForContext(pContext) ((pContext)->Context.RegistrationHandle)

// This function is for use by MC-generated code and should not be used directly.
// Initialize and register the caller-allocated context.
__inline
ULONG __stdcall
_mcgen_PASTE2(_mcgen_RegisterForContext_JonMon_, MCGEN_EVENTREGISTER)(
    _In_ LPCGUID pProviderId,
    _Out_ McGenContext_JonMon* pContext)
{
    RtlZeroMemory(pContext, sizeof(*pContext));
    pContext->Context.Logger = (ULONG_PTR)JonMonProvider_Traits;
    pContext->Context.EnableBitsCount = 1;
    pContext->Context.EnableBitMask = pContext->EnableBits;
    pContext->Context.EnableKeyWords = JonMonKeywords;
    pContext->Context.EnableLevel = JonMonLevels;
    return McGenEventRegister(
        pProviderId,
        McGenControlCallbackV2,
        &pContext->Context,
        &pContext->Context.RegistrationHandle);
}

// This function is for use by MC-generated code and should not be used directly.
// Trigger a compile error if called with the wrong parameter type.
FORCEINLINE
_Ret_ McGenContext_JonMon*
_mcgen_CheckContextType_JonMon(_In_ McGenContext_JonMon* pContext)
{
    return pContext;
}

#endif // MCGEN_ENABLE_FORCONTEXT_CODE_GENERATION

//
// Enablement check macro for event "ProcessCreation"
//
#define EventEnabledProcessCreation() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledProcessCreation_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "ProcessCreation"
//
#define EventWriteProcessCreation(Activity, EventTime_, NewProcessFilePath, NewProcessCommandLine, NewProcessId, NewProcessStartKey, NewProcessStartTime, NewProcessProcessUser, NewProcessUserLogonId, ParentProcessId, ParentProcessThreadId, ParentProcessFilePath, CreatorProcessId, ParentProcessUser, ParentProcessUserLogonId) \
        MCGEN_EVENT_ENABLED(ProcessCreation) \
        ? _mcgen_TEMPLATE_FOR_ProcessCreation(&JonMonProvider_Context, &ProcessCreation, Activity, EventTime_, NewProcessFilePath, NewProcessCommandLine, NewProcessId, NewProcessStartKey, NewProcessStartTime, NewProcessProcessUser, NewProcessUserLogonId, ParentProcessId, ParentProcessThreadId, ParentProcessFilePath, CreatorProcessId, ParentProcessUser, ParentProcessUserLogonId) : 0
#define EventWriteProcessCreation_AssumeEnabled(EventTime_, NewProcessFilePath, NewProcessCommandLine, NewProcessId, NewProcessStartKey, NewProcessStartTime, NewProcessProcessUser, NewProcessUserLogonId, ParentProcessId, ParentProcessThreadId, ParentProcessFilePath, CreatorProcessId, ParentProcessUser, ParentProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_ProcessCreation(&JonMonProvider_Context, &ProcessCreation, NULL, EventTime_, NewProcessFilePath, NewProcessCommandLine, NewProcessId, NewProcessStartKey, NewProcessStartTime, NewProcessProcessUser, NewProcessUserLogonId, ParentProcessId, ParentProcessThreadId, ParentProcessFilePath, CreatorProcessId, ParentProcessUser, ParentProcessUserLogonId)
#define EventWriteProcessCreation_ForContext(pContext, Activity, EventTime_, NewProcessFilePath, NewProcessCommandLine, NewProcessId, NewProcessStartKey, NewProcessStartTime, NewProcessProcessUser, NewProcessUserLogonId, ParentProcessId, ParentProcessThreadId, ParentProcessFilePath, CreatorProcessId, ParentProcessUser, ParentProcessUserLogonId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ProcessCreation) \
        ? _mcgen_TEMPLATE_FOR_ProcessCreation(&(pContext)->Context, &ProcessCreation, Activity, EventTime_, NewProcessFilePath, NewProcessCommandLine, NewProcessId, NewProcessStartKey, NewProcessStartTime, NewProcessProcessUser, NewProcessUserLogonId, ParentProcessId, ParentProcessThreadId, ParentProcessFilePath, CreatorProcessId, ParentProcessUser, ParentProcessUserLogonId) : 0
#define EventWriteProcessCreation_ForContextAssumeEnabled(pContext, EventTime_, NewProcessFilePath, NewProcessCommandLine, NewProcessId, NewProcessStartKey, NewProcessStartTime, NewProcessProcessUser, NewProcessUserLogonId, ParentProcessId, ParentProcessThreadId, ParentProcessFilePath, CreatorProcessId, ParentProcessUser, ParentProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_ProcessCreation(&_mcgen_CheckContextType_JonMon(pContext)->Context, &ProcessCreation, NULL, EventTime_, NewProcessFilePath, NewProcessCommandLine, NewProcessId, NewProcessStartKey, NewProcessStartTime, NewProcessProcessUser, NewProcessUserLogonId, ParentProcessId, ParentProcessThreadId, ParentProcessFilePath, CreatorProcessId, ParentProcessUser, ParentProcessUserLogonId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ProcessCreation _mcgen_PASTE2(McTemplateK0mzzxxxzqxxzxzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ProcessAccess"
//
#define EventEnabledProcessAccess() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledProcessAccess_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "ProcessAccess"
//
#define EventWriteProcessAccess(Activity, EventTime_, SourceProcessGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED(ProcessAccess) \
        ? _mcgen_TEMPLATE_FOR_ProcessAccess(&JonMonProvider_Context, &ProcessAccess, Activity, EventTime_, SourceProcessGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteProcessAccess_AssumeEnabled(EventTime_, SourceProcessGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_ProcessAccess(&JonMonProvider_Context, &ProcessAccess, NULL, EventTime_, SourceProcessGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId)
#define EventWriteProcessAccess_ForContext(pContext, Activity, EventTime_, SourceProcessGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ProcessAccess) \
        ? _mcgen_TEMPLATE_FOR_ProcessAccess(&(pContext)->Context, &ProcessAccess, Activity, EventTime_, SourceProcessGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteProcessAccess_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_ProcessAccess(&_mcgen_CheckContextType_JonMon(pContext)->Context, &ProcessAccess, NULL, EventTime_, SourceProcessGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ProcessAccess _mcgen_PASTE2(McTemplateK0mdxxzxxxzzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ProcessAccessDuplicated"
//
#define EventEnabledProcessAccessDuplicated() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledProcessAccessDuplicated_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "ProcessAccessDuplicated"
//
#define EventWriteProcessAccessDuplicated(Activity, EventTime_, SourceProcessDuplicatedGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED(ProcessAccessDuplicated) \
        ? _mcgen_TEMPLATE_FOR_ProcessAccessDuplicated(&JonMonProvider_Context, &ProcessAccessDuplicated, Activity, EventTime_, SourceProcessDuplicatedGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteProcessAccessDuplicated_AssumeEnabled(EventTime_, SourceProcessDuplicatedGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_ProcessAccessDuplicated(&JonMonProvider_Context, &ProcessAccessDuplicated, NULL, EventTime_, SourceProcessDuplicatedGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId)
#define EventWriteProcessAccessDuplicated_ForContext(pContext, Activity, EventTime_, SourceProcessDuplicatedGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ProcessAccessDuplicated) \
        ? _mcgen_TEMPLATE_FOR_ProcessAccessDuplicated(&(pContext)->Context, &ProcessAccessDuplicated, Activity, EventTime_, SourceProcessDuplicatedGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteProcessAccessDuplicated_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessDuplicatedGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_ProcessAccessDuplicated(&_mcgen_CheckContextType_JonMon(pContext)->Context, &ProcessAccessDuplicated, NULL, EventTime_, SourceProcessDuplicatedGrantedAccess, TargetProcessId, TargetProcessStartKey, TargetImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceProcessFilePath, SourceProcessUser, SourceProcessUserLogonId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ProcessAccessDuplicated _mcgen_PASTE2(McTemplateK0mdxxzxxxzzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ImageLoaded"
//
#define EventEnabledImageLoaded() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledImageLoaded_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "ImageLoaded"
//
#define EventWriteImageLoaded(Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, ModulePath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED(ImageLoaded) \
        ? _mcgen_TEMPLATE_FOR_ImageLoaded(&JonMonProvider_Context, &ImageLoaded, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, ModulePath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteImageLoaded_AssumeEnabled(EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, ModulePath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_ImageLoaded(&JonMonProvider_Context, &ImageLoaded, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, ModulePath, SourceProcessUser, SourceProcessUserLogonId)
#define EventWriteImageLoaded_ForContext(pContext, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, ModulePath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ImageLoaded) \
        ? _mcgen_TEMPLATE_FOR_ImageLoaded(&(pContext)->Context, &ImageLoaded, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, ModulePath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteImageLoaded_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, ModulePath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_ImageLoaded(&_mcgen_CheckContextType_JonMon(pContext)->Context, &ImageLoaded, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, ModulePath, SourceProcessUser, SourceProcessUserLogonId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ImageLoaded _mcgen_PASTE2(McTemplateK0mzxxxzzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RegistryCreateKey"
//
#define EventEnabledRegistryCreateKey() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledRegistryCreateKey_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "RegistryCreateKey"
//
#define EventWriteRegistryCreateKey(Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceRegistryKeyPath, SourceProcessGrantedAccess, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED(RegistryCreateKey) \
        ? _mcgen_TEMPLATE_FOR_RegistryCreateKey(&JonMonProvider_Context, &RegistryCreateKey, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceRegistryKeyPath, SourceProcessGrantedAccess, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteRegistryCreateKey_AssumeEnabled(EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceRegistryKeyPath, SourceProcessGrantedAccess, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_RegistryCreateKey(&JonMonProvider_Context, &RegistryCreateKey, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceRegistryKeyPath, SourceProcessGrantedAccess, SourceProcessUser, SourceProcessUserLogonId)
#define EventWriteRegistryCreateKey_ForContext(pContext, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceRegistryKeyPath, SourceProcessGrantedAccess, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RegistryCreateKey) \
        ? _mcgen_TEMPLATE_FOR_RegistryCreateKey(&(pContext)->Context, &RegistryCreateKey, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceRegistryKeyPath, SourceProcessGrantedAccess, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteRegistryCreateKey_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceRegistryKeyPath, SourceProcessGrantedAccess, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_RegistryCreateKey(&_mcgen_CheckContextType_JonMon(pContext)->Context, &RegistryCreateKey, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceRegistryKeyPath, SourceProcessGrantedAccess, SourceProcessUser, SourceProcessUserLogonId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RegistryCreateKey _mcgen_PASTE2(McTemplateK0mzxxxzdzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RegistryDeleteKey"
//
#define EventEnabledRegistryDeleteKey() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledRegistryDeleteKey_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "RegistryDeleteKey"
//
#define EventWriteRegistryDeleteKey(Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED(RegistryDeleteKey) \
        ? _mcgen_TEMPLATE_FOR_RegistryDeleteKey(&JonMonProvider_Context, &RegistryDeleteKey, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteRegistryDeleteKey_AssumeEnabled(EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_RegistryDeleteKey(&JonMonProvider_Context, &RegistryDeleteKey, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId)
#define EventWriteRegistryDeleteKey_ForContext(pContext, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RegistryDeleteKey) \
        ? _mcgen_TEMPLATE_FOR_RegistryDeleteKey(&(pContext)->Context, &RegistryDeleteKey, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteRegistryDeleteKey_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_RegistryDeleteKey(&_mcgen_CheckContextType_JonMon(pContext)->Context, &RegistryDeleteKey, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RegistryDeleteKey _mcgen_PASTE2(McTemplateK0mzxxxzzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RegistrySetValue"
//
#define EventEnabledRegistrySetValue() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledRegistrySetValue_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "RegistrySetValue"
//
#define EventWriteRegistrySetValue(Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, RegistryValueName, RegistryValueData, RegistryValueDataType, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED(RegistrySetValue) \
        ? _mcgen_TEMPLATE_FOR_RegistrySetValue(&JonMonProvider_Context, &RegistrySetValue, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, RegistryValueName, RegistryValueData, RegistryValueDataType, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteRegistrySetValue_AssumeEnabled(EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, RegistryValueName, RegistryValueData, RegistryValueDataType, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_RegistrySetValue(&JonMonProvider_Context, &RegistrySetValue, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, RegistryValueName, RegistryValueData, RegistryValueDataType, SourceProcessUser, SourceProcessUserLogonId)
#define EventWriteRegistrySetValue_ForContext(pContext, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, RegistryValueName, RegistryValueData, RegistryValueDataType, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RegistrySetValue) \
        ? _mcgen_TEMPLATE_FOR_RegistrySetValue(&(pContext)->Context, &RegistrySetValue, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, RegistryValueName, RegistryValueData, RegistryValueDataType, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteRegistrySetValue_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, RegistryValueName, RegistryValueData, RegistryValueDataType, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_RegistrySetValue(&_mcgen_CheckContextType_JonMon(pContext)->Context, &RegistrySetValue, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, RegistryValueName, RegistryValueData, RegistryValueDataType, SourceProcessUser, SourceProcessUserLogonId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RegistrySetValue _mcgen_PASTE2(McTemplateK0mzxxxzzzzzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ProcessReparenting"
//
#define EventEnabledProcessReparenting() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledProcessReparenting_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "ProcessReparenting"
//
#define EventWriteProcessReparenting(Activity, EventTime_, NewProcessFilePath, NewProcessCommandLine, ParentProcessId, ParentThreadId, NewProcessId, NewProcessStartKey, NewProcessStartTime, ParentProcessFilePath, CreatorProcessId, CreatorProcessFilePath, CreatorProcessUser, ParentProcessUser, NewProcessUser, ParentProcessLogonId, NewProcessUserLogonId, CreatorProcessLogonId) \
        MCGEN_EVENT_ENABLED(ProcessReparenting) \
        ? _mcgen_TEMPLATE_FOR_ProcessReparenting(&JonMonProvider_Context, &ProcessReparenting, Activity, EventTime_, NewProcessFilePath, NewProcessCommandLine, ParentProcessId, ParentThreadId, NewProcessId, NewProcessStartKey, NewProcessStartTime, ParentProcessFilePath, CreatorProcessId, CreatorProcessFilePath, CreatorProcessUser, ParentProcessUser, NewProcessUser, ParentProcessLogonId, NewProcessUserLogonId, CreatorProcessLogonId) : 0
#define EventWriteProcessReparenting_AssumeEnabled(EventTime_, NewProcessFilePath, NewProcessCommandLine, ParentProcessId, ParentThreadId, NewProcessId, NewProcessStartKey, NewProcessStartTime, ParentProcessFilePath, CreatorProcessId, CreatorProcessFilePath, CreatorProcessUser, ParentProcessUser, NewProcessUser, ParentProcessLogonId, NewProcessUserLogonId, CreatorProcessLogonId) \
        _mcgen_TEMPLATE_FOR_ProcessReparenting(&JonMonProvider_Context, &ProcessReparenting, NULL, EventTime_, NewProcessFilePath, NewProcessCommandLine, ParentProcessId, ParentThreadId, NewProcessId, NewProcessStartKey, NewProcessStartTime, ParentProcessFilePath, CreatorProcessId, CreatorProcessFilePath, CreatorProcessUser, ParentProcessUser, NewProcessUser, ParentProcessLogonId, NewProcessUserLogonId, CreatorProcessLogonId)
#define EventWriteProcessReparenting_ForContext(pContext, Activity, EventTime_, NewProcessFilePath, NewProcessCommandLine, ParentProcessId, ParentThreadId, NewProcessId, NewProcessStartKey, NewProcessStartTime, ParentProcessFilePath, CreatorProcessId, CreatorProcessFilePath, CreatorProcessUser, ParentProcessUser, NewProcessUser, ParentProcessLogonId, NewProcessUserLogonId, CreatorProcessLogonId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ProcessReparenting) \
        ? _mcgen_TEMPLATE_FOR_ProcessReparenting(&(pContext)->Context, &ProcessReparenting, Activity, EventTime_, NewProcessFilePath, NewProcessCommandLine, ParentProcessId, ParentThreadId, NewProcessId, NewProcessStartKey, NewProcessStartTime, ParentProcessFilePath, CreatorProcessId, CreatorProcessFilePath, CreatorProcessUser, ParentProcessUser, NewProcessUser, ParentProcessLogonId, NewProcessUserLogonId, CreatorProcessLogonId) : 0
#define EventWriteProcessReparenting_ForContextAssumeEnabled(pContext, EventTime_, NewProcessFilePath, NewProcessCommandLine, ParentProcessId, ParentThreadId, NewProcessId, NewProcessStartKey, NewProcessStartTime, ParentProcessFilePath, CreatorProcessId, CreatorProcessFilePath, CreatorProcessUser, ParentProcessUser, NewProcessUser, ParentProcessLogonId, NewProcessUserLogonId, CreatorProcessLogonId) \
        _mcgen_TEMPLATE_FOR_ProcessReparenting(&_mcgen_CheckContextType_JonMon(pContext)->Context, &ProcessReparenting, NULL, EventTime_, NewProcessFilePath, NewProcessCommandLine, ParentProcessId, ParentThreadId, NewProcessId, NewProcessStartKey, NewProcessStartTime, ParentProcessFilePath, CreatorProcessId, CreatorProcessFilePath, CreatorProcessUser, ParentProcessUser, NewProcessUser, ParentProcessLogonId, NewProcessUserLogonId, CreatorProcessLogonId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ProcessReparenting _mcgen_PASTE2(McTemplateK0mzzxxxxxzxzzzzqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ProcessTerminate"
//
#define EventEnabledProcessTerminate() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledProcessTerminate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "ProcessTerminate"
//
#define EventWriteProcessTerminate(Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, TargetProcessFilePath, TargetProcessId) \
        MCGEN_EVENT_ENABLED(ProcessTerminate) \
        ? _mcgen_TEMPLATE_FOR_ProcessTerminate(&JonMonProvider_Context, &ProcessTerminate, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, TargetProcessFilePath, TargetProcessId) : 0
#define EventWriteProcessTerminate_AssumeEnabled(EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, TargetProcessFilePath, TargetProcessId) \
        _mcgen_TEMPLATE_FOR_ProcessTerminate(&JonMonProvider_Context, &ProcessTerminate, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, TargetProcessFilePath, TargetProcessId)
#define EventWriteProcessTerminate_ForContext(pContext, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, TargetProcessFilePath, TargetProcessId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ProcessTerminate) \
        ? _mcgen_TEMPLATE_FOR_ProcessTerminate(&(pContext)->Context, &ProcessTerminate, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, TargetProcessFilePath, TargetProcessId) : 0
#define EventWriteProcessTerminate_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, TargetProcessFilePath, TargetProcessId) \
        _mcgen_TEMPLATE_FOR_ProcessTerminate(&_mcgen_CheckContextType_JonMon(pContext)->Context, &ProcessTerminate, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, TargetProcessFilePath, TargetProcessId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ProcessTerminate _mcgen_PASTE2(McTemplateK0mzxxzx_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FileRename"
//
#define EventEnabledFileRename() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledFileRename_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "FileRename"
//
#define EventWriteFileRename(Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        MCGEN_EVENT_ENABLED(FileRename) \
        ? _mcgen_TEMPLATE_FOR_FileRename(&JonMonProvider_Context, &FileRename, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) : 0
#define EventWriteFileRename_AssumeEnabled(EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        _mcgen_TEMPLATE_FOR_FileRename(&JonMonProvider_Context, &FileRename, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile)
#define EventWriteFileRename_ForContext(pContext, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FileRename) \
        ? _mcgen_TEMPLATE_FOR_FileRename(&(pContext)->Context, &FileRename, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) : 0
#define EventWriteFileRename_ForContextAssumeEnabled(pContext, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        _mcgen_TEMPLATE_FOR_FileRename(&_mcgen_CheckContextType_JonMon(pContext)->Context, &FileRename, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FileRename _mcgen_PASTE2(McTemplateK0mzxxxzqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RPCClientCall"
//
#define EventEnabledRPCClientCall() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledRPCClientCall_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "RPCClientCall"
//
#define EventWriteRPCClientCall(Activity, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) \
        MCGEN_EVENT_ENABLED(RPCClientCall) \
        ? _mcgen_TEMPLATE_FOR_RPCClientCall(&JonMonProvider_Context, &RPCClientCall, Activity, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) : 0
#define EventWriteRPCClientCall_AssumeEnabled(EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) \
        _mcgen_TEMPLATE_FOR_RPCClientCall(&JonMonProvider_Context, &RPCClientCall, NULL, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack)
#define EventWriteRPCClientCall_ForContext(pContext, Activity, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RPCClientCall) \
        ? _mcgen_TEMPLATE_FOR_RPCClientCall(&(pContext)->Context, &RPCClientCall, Activity, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) : 0
#define EventWriteRPCClientCall_ForContextAssumeEnabled(pContext, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) \
        _mcgen_TEMPLATE_FOR_RPCClientCall(&_mcgen_CheckContextType_JonMon(pContext)->Context, &RPCClientCall, NULL, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RPCClientCall _mcgen_PASTE2(McTemplateK0mzqqqzzzzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RPCServerCall"
//
#define EventEnabledRPCServerCall() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledRPCServerCall_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "RPCServerCall"
//
#define EventWriteRPCServerCall(Activity, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) \
        MCGEN_EVENT_ENABLED(RPCServerCall) \
        ? _mcgen_TEMPLATE_FOR_RPCServerCall(&JonMonProvider_Context, &RPCServerCall, Activity, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) : 0
#define EventWriteRPCServerCall_AssumeEnabled(EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) \
        _mcgen_TEMPLATE_FOR_RPCServerCall(&JonMonProvider_Context, &RPCServerCall, NULL, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack)
#define EventWriteRPCServerCall_ForContext(pContext, Activity, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RPCServerCall) \
        ? _mcgen_TEMPLATE_FOR_RPCServerCall(&(pContext)->Context, &RPCServerCall, Activity, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) : 0
#define EventWriteRPCServerCall_ForContextAssumeEnabled(pContext, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack) \
        _mcgen_TEMPLATE_FOR_RPCServerCall(&_mcgen_CheckContextType_JonMon(pContext)->Context, &RPCServerCall, NULL, EventTime_, Interface_UUID, ProcNum, Protocol, ProcessId, NetworkAddress, Endpoint, InterfaceString, MethodString, ProcessUser, ProcessFilePath, CallStack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RPCServerCall _mcgen_PASTE2(McTemplateK0mzqqqzzzzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "NetworkConnectionAccepted"
//
#define EventEnabledNetworkConnectionAccepted() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledNetworkConnectionAccepted_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "NetworkConnectionAccepted"
//
#define EventWriteNetworkConnectionAccepted(Activity, EventTime_, ProcessId, SrcIpAddressIpv4, DestIpAddressIpv4, SrcPort, DestPort, Initiated, ProcessUser, ProcessFilePath) \
        MCGEN_EVENT_ENABLED(NetworkConnectionAccepted) \
        ? _mcgen_TEMPLATE_FOR_NetworkConnectionAccepted(&JonMonProvider_Context, &NetworkConnectionAccepted, Activity, EventTime_, ProcessId, SrcIpAddressIpv4, DestIpAddressIpv4, SrcPort, DestPort, Initiated, ProcessUser, ProcessFilePath) : 0
#define EventWriteNetworkConnectionAccepted_AssumeEnabled(EventTime_, ProcessId, SrcIpAddressIpv4, DestIpAddressIpv4, SrcPort, DestPort, Initiated, ProcessUser, ProcessFilePath) \
        _mcgen_TEMPLATE_FOR_NetworkConnectionAccepted(&JonMonProvider_Context, &NetworkConnectionAccepted, NULL, EventTime_, ProcessId, SrcIpAddressIpv4, DestIpAddressIpv4, SrcPort, DestPort, Initiated, ProcessUser, ProcessFilePath)
#define EventWriteNetworkConnectionAccepted_ForContext(pContext, Activity, EventTime_, ProcessId, SrcIpAddressIpv4, DestIpAddressIpv4, SrcPort, DestPort, Initiated, ProcessUser, ProcessFilePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, NetworkConnectionAccepted) \
        ? _mcgen_TEMPLATE_FOR_NetworkConnectionAccepted(&(pContext)->Context, &NetworkConnectionAccepted, Activity, EventTime_, ProcessId, SrcIpAddressIpv4, DestIpAddressIpv4, SrcPort, DestPort, Initiated, ProcessUser, ProcessFilePath) : 0
#define EventWriteNetworkConnectionAccepted_ForContextAssumeEnabled(pContext, EventTime_, ProcessId, SrcIpAddressIpv4, DestIpAddressIpv4, SrcPort, DestPort, Initiated, ProcessUser, ProcessFilePath) \
        _mcgen_TEMPLATE_FOR_NetworkConnectionAccepted(&_mcgen_CheckContextType_JonMon(pContext)->Context, &NetworkConnectionAccepted, NULL, EventTime_, ProcessId, SrcIpAddressIpv4, DestIpAddressIpv4, SrcPort, DestPort, Initiated, ProcessUser, ProcessFilePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_NetworkConnectionAccepted _mcgen_PASTE2(McTemplateK0mqzzhhzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RegistrySaveKey"
//
#define EventEnabledRegistrySaveKey() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledRegistrySaveKey_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "RegistrySaveKey"
//
#define EventWriteRegistrySaveKey(Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED(RegistrySaveKey) \
        ? _mcgen_TEMPLATE_FOR_RegistrySaveKey(&JonMonProvider_Context, &RegistrySaveKey, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteRegistrySaveKey_AssumeEnabled(EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_RegistrySaveKey(&JonMonProvider_Context, &RegistrySaveKey, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId)
#define EventWriteRegistrySaveKey_ForContext(pContext, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RegistrySaveKey) \
        ? _mcgen_TEMPLATE_FOR_RegistrySaveKey(&(pContext)->Context, &RegistrySaveKey, Activity, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) : 0
#define EventWriteRegistrySaveKey_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId) \
        _mcgen_TEMPLATE_FOR_RegistrySaveKey(&_mcgen_CheckContextType_JonMon(pContext)->Context, &RegistrySaveKey, NULL, EventTime_, SourceProcessFilePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, RegistryKeyPath, SourceProcessUser, SourceProcessUserLogonId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RegistrySaveKey _mcgen_PASTE2(McTemplateK0mzxxxzzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DotNetLoad"
//
#define EventEnabledDotNetLoad() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledDotNetLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "DotNetLoad"
//
#define EventWriteDotNetLoad(Activity, EventTime_, ProcessId, AssemblyName, ProcessUser, ProcessFilePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED(DotNetLoad) \
        ? _mcgen_TEMPLATE_FOR_DotNetLoad(&JonMonProvider_Context, &DotNetLoad, Activity, EventTime_, ProcessId, AssemblyName, ProcessUser, ProcessFilePath, ClrInstanceID) : 0
#define EventWriteDotNetLoad_AssumeEnabled(EventTime_, ProcessId, AssemblyName, ProcessUser, ProcessFilePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DotNetLoad(&JonMonProvider_Context, &DotNetLoad, NULL, EventTime_, ProcessId, AssemblyName, ProcessUser, ProcessFilePath, ClrInstanceID)
#define EventWriteDotNetLoad_ForContext(pContext, Activity, EventTime_, ProcessId, AssemblyName, ProcessUser, ProcessFilePath, ClrInstanceID) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DotNetLoad) \
        ? _mcgen_TEMPLATE_FOR_DotNetLoad(&(pContext)->Context, &DotNetLoad, Activity, EventTime_, ProcessId, AssemblyName, ProcessUser, ProcessFilePath, ClrInstanceID) : 0
#define EventWriteDotNetLoad_ForContextAssumeEnabled(pContext, EventTime_, ProcessId, AssemblyName, ProcessUser, ProcessFilePath, ClrInstanceID) \
        _mcgen_TEMPLATE_FOR_DotNetLoad(&_mcgen_CheckContextType_JonMon(pContext)->Context, &DotNetLoad, NULL, EventTime_, ProcessId, AssemblyName, ProcessUser, ProcessFilePath, ClrInstanceID)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DotNetLoad _mcgen_PASTE2(McTemplateK0mqzzzh_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "AMSI"
//
#define EventEnabledAMSI() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledAMSI_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "AMSI"
//
#define EventWriteAMSI(Activity, EventTime_, ProcessId, AppName, ScanResults, ContentSize) \
        MCGEN_EVENT_ENABLED(AMSI) \
        ? _mcgen_TEMPLATE_FOR_AMSI(&JonMonProvider_Context, &AMSI, Activity, EventTime_, ProcessId, AppName, ScanResults, ContentSize) : 0
#define EventWriteAMSI_AssumeEnabled(EventTime_, ProcessId, AppName, ScanResults, ContentSize) \
        _mcgen_TEMPLATE_FOR_AMSI(&JonMonProvider_Context, &AMSI, NULL, EventTime_, ProcessId, AppName, ScanResults, ContentSize)
#define EventWriteAMSI_ForContext(pContext, Activity, EventTime_, ProcessId, AppName, ScanResults, ContentSize) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, AMSI) \
        ? _mcgen_TEMPLATE_FOR_AMSI(&(pContext)->Context, &AMSI, Activity, EventTime_, ProcessId, AppName, ScanResults, ContentSize) : 0
#define EventWriteAMSI_ForContextAssumeEnabled(pContext, EventTime_, ProcessId, AppName, ScanResults, ContentSize) \
        _mcgen_TEMPLATE_FOR_AMSI(&_mcgen_CheckContextType_JonMon(pContext)->Context, &AMSI, NULL, EventTime_, ProcessId, AppName, ScanResults, ContentSize)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_AMSI _mcgen_PASTE2(McTemplateK0mqzqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ImpersonationAction"
//
#define EventEnabledImpersonationAction() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledImpersonationAction_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "ImpersonationAction"
//
#define EventWriteImpersonationAction(Activity, EventTime_, ProcessName, ProcessId, ProcessStartKey, ProcessIntegrityLevel, ProcessUserName, ThreadId, ImpersonationLevel, ImpersonationLevelName, ImpersonatedUserName, ThreadIntegrityLevel, OperationType) \
        MCGEN_EVENT_ENABLED(ImpersonationAction) \
        ? _mcgen_TEMPLATE_FOR_ImpersonationAction(&JonMonProvider_Context, &ImpersonationAction, Activity, EventTime_, ProcessName, ProcessId, ProcessStartKey, ProcessIntegrityLevel, ProcessUserName, ThreadId, ImpersonationLevel, ImpersonationLevelName, ImpersonatedUserName, ThreadIntegrityLevel, OperationType) : 0
#define EventWriteImpersonationAction_AssumeEnabled(EventTime_, ProcessName, ProcessId, ProcessStartKey, ProcessIntegrityLevel, ProcessUserName, ThreadId, ImpersonationLevel, ImpersonationLevelName, ImpersonatedUserName, ThreadIntegrityLevel, OperationType) \
        _mcgen_TEMPLATE_FOR_ImpersonationAction(&JonMonProvider_Context, &ImpersonationAction, NULL, EventTime_, ProcessName, ProcessId, ProcessStartKey, ProcessIntegrityLevel, ProcessUserName, ThreadId, ImpersonationLevel, ImpersonationLevelName, ImpersonatedUserName, ThreadIntegrityLevel, OperationType)
#define EventWriteImpersonationAction_ForContext(pContext, Activity, EventTime_, ProcessName, ProcessId, ProcessStartKey, ProcessIntegrityLevel, ProcessUserName, ThreadId, ImpersonationLevel, ImpersonationLevelName, ImpersonatedUserName, ThreadIntegrityLevel, OperationType) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ImpersonationAction) \
        ? _mcgen_TEMPLATE_FOR_ImpersonationAction(&(pContext)->Context, &ImpersonationAction, Activity, EventTime_, ProcessName, ProcessId, ProcessStartKey, ProcessIntegrityLevel, ProcessUserName, ThreadId, ImpersonationLevel, ImpersonationLevelName, ImpersonatedUserName, ThreadIntegrityLevel, OperationType) : 0
#define EventWriteImpersonationAction_ForContextAssumeEnabled(pContext, EventTime_, ProcessName, ProcessId, ProcessStartKey, ProcessIntegrityLevel, ProcessUserName, ThreadId, ImpersonationLevel, ImpersonationLevelName, ImpersonatedUserName, ThreadIntegrityLevel, OperationType) \
        _mcgen_TEMPLATE_FOR_ImpersonationAction(&_mcgen_CheckContextType_JonMon(pContext)->Context, &ImpersonationAction, NULL, EventTime_, ProcessName, ProcessId, ProcessStartKey, ProcessIntegrityLevel, ProcessUserName, ThreadId, ImpersonationLevel, ImpersonationLevelName, ImpersonatedUserName, ThreadIntegrityLevel, OperationType)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ImpersonationAction _mcgen_PASTE2(McTemplateK0mzxxzzxdzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "RemoteThreadCreation"
//
#define EventEnabledRemoteThreadCreation() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledRemoteThreadCreation_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "RemoteThreadCreation"
//
#define EventWriteRemoteThreadCreation(Activity, EventTime_, SourceImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetImagePath, TargetProcessId, TargetProcessStartKey, TargetThreadId, TargetUserName, TargetUserLogonId, TargetProcessIntegrityLevel) \
        MCGEN_EVENT_ENABLED(RemoteThreadCreation) \
        ? _mcgen_TEMPLATE_FOR_RemoteThreadCreation(&JonMonProvider_Context, &RemoteThreadCreation, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetImagePath, TargetProcessId, TargetProcessStartKey, TargetThreadId, TargetUserName, TargetUserLogonId, TargetProcessIntegrityLevel) : 0
#define EventWriteRemoteThreadCreation_AssumeEnabled(EventTime_, SourceImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetImagePath, TargetProcessId, TargetProcessStartKey, TargetThreadId, TargetUserName, TargetUserLogonId, TargetProcessIntegrityLevel) \
        _mcgen_TEMPLATE_FOR_RemoteThreadCreation(&JonMonProvider_Context, &RemoteThreadCreation, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetImagePath, TargetProcessId, TargetProcessStartKey, TargetThreadId, TargetUserName, TargetUserLogonId, TargetProcessIntegrityLevel)
#define EventWriteRemoteThreadCreation_ForContext(pContext, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetImagePath, TargetProcessId, TargetProcessStartKey, TargetThreadId, TargetUserName, TargetUserLogonId, TargetProcessIntegrityLevel) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, RemoteThreadCreation) \
        ? _mcgen_TEMPLATE_FOR_RemoteThreadCreation(&(pContext)->Context, &RemoteThreadCreation, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetImagePath, TargetProcessId, TargetProcessStartKey, TargetThreadId, TargetUserName, TargetUserLogonId, TargetProcessIntegrityLevel) : 0
#define EventWriteRemoteThreadCreation_ForContextAssumeEnabled(pContext, EventTime_, SourceImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetImagePath, TargetProcessId, TargetProcessStartKey, TargetThreadId, TargetUserName, TargetUserLogonId, TargetProcessIntegrityLevel) \
        _mcgen_TEMPLATE_FOR_RemoteThreadCreation(&_mcgen_CheckContextType_JonMon(pContext)->Context, &RemoteThreadCreation, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceThreadId, SourceProcessStartKey, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetImagePath, TargetProcessId, TargetProcessStartKey, TargetThreadId, TargetUserName, TargetUserLogonId, TargetProcessIntegrityLevel)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_RemoteThreadCreation _mcgen_PASTE2(McTemplateK0mzxxxzqzzxxxzqz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "SchedTaskCreation"
//
#define EventEnabledSchedTaskCreation() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledSchedTaskCreation_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "SchedTaskCreation"
//
#define EventWriteSchedTaskCreation(Activity, EventTime_, TaskName, UserName, SourceProcessId) \
        MCGEN_EVENT_ENABLED(SchedTaskCreation) \
        ? _mcgen_TEMPLATE_FOR_SchedTaskCreation(&JonMonProvider_Context, &SchedTaskCreation, Activity, EventTime_, TaskName, UserName, SourceProcessId) : 0
#define EventWriteSchedTaskCreation_AssumeEnabled(EventTime_, TaskName, UserName, SourceProcessId) \
        _mcgen_TEMPLATE_FOR_SchedTaskCreation(&JonMonProvider_Context, &SchedTaskCreation, NULL, EventTime_, TaskName, UserName, SourceProcessId)
#define EventWriteSchedTaskCreation_ForContext(pContext, Activity, EventTime_, TaskName, UserName, SourceProcessId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SchedTaskCreation) \
        ? _mcgen_TEMPLATE_FOR_SchedTaskCreation(&(pContext)->Context, &SchedTaskCreation, Activity, EventTime_, TaskName, UserName, SourceProcessId) : 0
#define EventWriteSchedTaskCreation_ForContextAssumeEnabled(pContext, EventTime_, TaskName, UserName, SourceProcessId) \
        _mcgen_TEMPLATE_FOR_SchedTaskCreation(&_mcgen_CheckContextType_JonMon(pContext)->Context, &SchedTaskCreation, NULL, EventTime_, TaskName, UserName, SourceProcessId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SchedTaskCreation _mcgen_PASTE2(McTemplateK0mzzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "SchedTaskStarted"
//
#define EventEnabledSchedTaskStarted() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledSchedTaskStarted_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "SchedTaskStarted"
//
#define EventWriteSchedTaskStarted(Activity, EventTime_, TaskName, ImagePath, SourceProcessId) \
        MCGEN_EVENT_ENABLED(SchedTaskStarted) \
        ? _mcgen_TEMPLATE_FOR_SchedTaskStarted(&JonMonProvider_Context, &SchedTaskStarted, Activity, EventTime_, TaskName, ImagePath, SourceProcessId) : 0
#define EventWriteSchedTaskStarted_AssumeEnabled(EventTime_, TaskName, ImagePath, SourceProcessId) \
        _mcgen_TEMPLATE_FOR_SchedTaskStarted(&JonMonProvider_Context, &SchedTaskStarted, NULL, EventTime_, TaskName, ImagePath, SourceProcessId)
#define EventWriteSchedTaskStarted_ForContext(pContext, Activity, EventTime_, TaskName, ImagePath, SourceProcessId) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, SchedTaskStarted) \
        ? _mcgen_TEMPLATE_FOR_SchedTaskStarted(&(pContext)->Context, &SchedTaskStarted, Activity, EventTime_, TaskName, ImagePath, SourceProcessId) : 0
#define EventWriteSchedTaskStarted_ForContextAssumeEnabled(pContext, EventTime_, TaskName, ImagePath, SourceProcessId) \
        _mcgen_TEMPLATE_FOR_SchedTaskStarted(&_mcgen_CheckContextType_JonMon(pContext)->Context, &SchedTaskStarted, NULL, EventTime_, TaskName, ImagePath, SourceProcessId)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_SchedTaskStarted _mcgen_PASTE2(McTemplateK0mzzq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FileCreate"
//
#define EventEnabledFileCreate() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledFileCreate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "FileCreate"
//
#define EventWriteFileCreate(Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        MCGEN_EVENT_ENABLED(FileCreate) \
        ? _mcgen_TEMPLATE_FOR_FileCreate(&JonMonProvider_Context, &FileCreate, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) : 0
#define EventWriteFileCreate_AssumeEnabled(EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        _mcgen_TEMPLATE_FOR_FileCreate(&JonMonProvider_Context, &FileCreate, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile)
#define EventWriteFileCreate_ForContext(pContext, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FileCreate) \
        ? _mcgen_TEMPLATE_FOR_FileCreate(&(pContext)->Context, &FileCreate, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) : 0
#define EventWriteFileCreate_ForContextAssumeEnabled(pContext, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        _mcgen_TEMPLATE_FOR_FileCreate(&_mcgen_CheckContextType_JonMon(pContext)->Context, &FileCreate, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FileCreate _mcgen_PASTE2(McTemplateK0mzxxxzqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "FileDelete"
//
#define EventEnabledFileDelete() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledFileDelete_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "FileDelete"
//
#define EventWriteFileDelete(Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        MCGEN_EVENT_ENABLED(FileDelete) \
        ? _mcgen_TEMPLATE_FOR_FileDelete(&JonMonProvider_Context, &FileDelete, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) : 0
#define EventWriteFileDelete_AssumeEnabled(EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        _mcgen_TEMPLATE_FOR_FileDelete(&JonMonProvider_Context, &FileDelete, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile)
#define EventWriteFileDelete_ForContext(pContext, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, FileDelete) \
        ? _mcgen_TEMPLATE_FOR_FileDelete(&(pContext)->Context, &FileDelete, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) : 0
#define EventWriteFileDelete_ForContextAssumeEnabled(pContext, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile) \
        _mcgen_TEMPLATE_FOR_FileDelete(&_mcgen_CheckContextType_JonMon(pContext)->Context, &FileDelete, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, TargetFile)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_FileDelete _mcgen_PASTE2(McTemplateK0mzxxxzqzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "NamedPipeCreate"
//
#define EventEnabledNamedPipeCreate() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledNamedPipeCreate_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "NamedPipeCreate"
//
#define EventWriteNamedPipeCreate(Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, RemoteCreation, PipeCreationAccess) \
        MCGEN_EVENT_ENABLED(NamedPipeCreate) \
        ? _mcgen_TEMPLATE_FOR_NamedPipeCreate(&JonMonProvider_Context, &NamedPipeCreate, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, RemoteCreation, PipeCreationAccess) : 0
#define EventWriteNamedPipeCreate_AssumeEnabled(EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, RemoteCreation, PipeCreationAccess) \
        _mcgen_TEMPLATE_FOR_NamedPipeCreate(&JonMonProvider_Context, &NamedPipeCreate, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, RemoteCreation, PipeCreationAccess)
#define EventWriteNamedPipeCreate_ForContext(pContext, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, RemoteCreation, PipeCreationAccess) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, NamedPipeCreate) \
        ? _mcgen_TEMPLATE_FOR_NamedPipeCreate(&(pContext)->Context, &NamedPipeCreate, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, RemoteCreation, PipeCreationAccess) : 0
#define EventWriteNamedPipeCreate_ForContextAssumeEnabled(pContext, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, RemoteCreation, PipeCreationAccess) \
        _mcgen_TEMPLATE_FOR_NamedPipeCreate(&_mcgen_CheckContextType_JonMon(pContext)->Context, &NamedPipeCreate, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, RemoteCreation, PipeCreationAccess)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_NamedPipeCreate _mcgen_PASTE2(McTemplateK0mzxxxzqzztd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "NamedPipeOpen"
//
#define EventEnabledNamedPipeOpen() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledNamedPipeOpen_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "NamedPipeOpen"
//
#define EventWriteNamedPipeOpen(Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, PipeRequestedAccess, PipeGrantedAccess) \
        MCGEN_EVENT_ENABLED(NamedPipeOpen) \
        ? _mcgen_TEMPLATE_FOR_NamedPipeOpen(&JonMonProvider_Context, &NamedPipeOpen, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, PipeRequestedAccess, PipeGrantedAccess) : 0
#define EventWriteNamedPipeOpen_AssumeEnabled(EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, PipeRequestedAccess, PipeGrantedAccess) \
        _mcgen_TEMPLATE_FOR_NamedPipeOpen(&JonMonProvider_Context, &NamedPipeOpen, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, PipeRequestedAccess, PipeGrantedAccess)
#define EventWriteNamedPipeOpen_ForContext(pContext, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, PipeRequestedAccess, PipeGrantedAccess) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, NamedPipeOpen) \
        ? _mcgen_TEMPLATE_FOR_NamedPipeOpen(&(pContext)->Context, &NamedPipeOpen, Activity, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, PipeRequestedAccess, PipeGrantedAccess) : 0
#define EventWriteNamedPipeOpen_ForContextAssumeEnabled(pContext, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, PipeRequestedAccess, PipeGrantedAccess) \
        _mcgen_TEMPLATE_FOR_NamedPipeOpen(&_mcgen_CheckContextType_JonMon(pContext)->Context, &NamedPipeOpen, NULL, EventTime_, SourceImagePath, SourceProcessId, SourceProcessStartKey, SourceThreadId, SourceUserName, SourceUserLogonId, SourceProcessIntegrityLevel, PipeName, PipeRequestedAccess, PipeGrantedAccess)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_NamedPipeOpen _mcgen_PASTE2(McTemplateK0mzxxxzqzzdd_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "WMIFilterToConsumerBinding"
//
#define EventEnabledWMIFilterToConsumerBinding() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledWMIFilterToConsumerBinding_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "WMIFilterToConsumerBinding"
//
#define EventWriteWMIFilterToConsumerBinding(Activity, EventTime_, Namespace, ESS, Consumer, PossibleCause) \
        MCGEN_EVENT_ENABLED(WMIFilterToConsumerBinding) \
        ? _mcgen_TEMPLATE_FOR_WMIFilterToConsumerBinding(&JonMonProvider_Context, &WMIFilterToConsumerBinding, Activity, EventTime_, Namespace, ESS, Consumer, PossibleCause) : 0
#define EventWriteWMIFilterToConsumerBinding_AssumeEnabled(EventTime_, Namespace, ESS, Consumer, PossibleCause) \
        _mcgen_TEMPLATE_FOR_WMIFilterToConsumerBinding(&JonMonProvider_Context, &WMIFilterToConsumerBinding, NULL, EventTime_, Namespace, ESS, Consumer, PossibleCause)
#define EventWriteWMIFilterToConsumerBinding_ForContext(pContext, Activity, EventTime_, Namespace, ESS, Consumer, PossibleCause) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, WMIFilterToConsumerBinding) \
        ? _mcgen_TEMPLATE_FOR_WMIFilterToConsumerBinding(&(pContext)->Context, &WMIFilterToConsumerBinding, Activity, EventTime_, Namespace, ESS, Consumer, PossibleCause) : 0
#define EventWriteWMIFilterToConsumerBinding_ForContextAssumeEnabled(pContext, EventTime_, Namespace, ESS, Consumer, PossibleCause) \
        _mcgen_TEMPLATE_FOR_WMIFilterToConsumerBinding(&_mcgen_CheckContextType_JonMon(pContext)->Context, &WMIFilterToConsumerBinding, NULL, EventTime_, Namespace, ESS, Consumer, PossibleCause)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_WMIFilterToConsumerBinding _mcgen_PASTE2(McTemplateK0mzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TIQueueUserAPCEvent"
//
#define EventEnabledTIQueueUserAPCEvent() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledTIQueueUserAPCEvent_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "TIQueueUserAPCEvent"
//
#define EventWriteTIQueueUserAPCEvent(Activity, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, TargetThreadId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, APCRoutine, APCArgument, SourceProcessFilePath, TargetProcessFilePath, CallStack) \
        MCGEN_EVENT_ENABLED(TIQueueUserAPCEvent) \
        ? _mcgen_TEMPLATE_FOR_TIQueueUserAPCEvent(&JonMonProvider_Context, &TIQueueUserAPCEvent, Activity, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, TargetThreadId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, APCRoutine, APCArgument, SourceProcessFilePath, TargetProcessFilePath, CallStack) : 0
#define EventWriteTIQueueUserAPCEvent_AssumeEnabled(EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, TargetThreadId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, APCRoutine, APCArgument, SourceProcessFilePath, TargetProcessFilePath, CallStack) \
        _mcgen_TEMPLATE_FOR_TIQueueUserAPCEvent(&JonMonProvider_Context, &TIQueueUserAPCEvent, NULL, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, TargetThreadId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, APCRoutine, APCArgument, SourceProcessFilePath, TargetProcessFilePath, CallStack)
#define EventWriteTIQueueUserAPCEvent_ForContext(pContext, Activity, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, TargetThreadId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, APCRoutine, APCArgument, SourceProcessFilePath, TargetProcessFilePath, CallStack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TIQueueUserAPCEvent) \
        ? _mcgen_TEMPLATE_FOR_TIQueueUserAPCEvent(&(pContext)->Context, &TIQueueUserAPCEvent, Activity, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, TargetThreadId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, APCRoutine, APCArgument, SourceProcessFilePath, TargetProcessFilePath, CallStack) : 0
#define EventWriteTIQueueUserAPCEvent_ForContextAssumeEnabled(pContext, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, TargetThreadId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, APCRoutine, APCArgument, SourceProcessFilePath, TargetProcessFilePath, CallStack) \
        _mcgen_TEMPLATE_FOR_TIQueueUserAPCEvent(&_mcgen_CheckContextType_JonMon(pContext)->Context, &TIQueueUserAPCEvent, NULL, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, TargetThreadId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, APCRoutine, APCArgument, SourceProcessFilePath, TargetProcessFilePath, CallStack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TIQueueUserAPCEvent _mcgen_PASTE2(McTemplateK0mqqqqxxqppzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DriverLoad"
//
#define EventEnabledDriverLoad() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledDriverLoad_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "DriverLoad"
//
#define EventWriteDriverLoad(Activity, EventTime_, ModulePath) \
        MCGEN_EVENT_ENABLED(DriverLoad) \
        ? _mcgen_TEMPLATE_FOR_DriverLoad(&JonMonProvider_Context, &DriverLoad, Activity, EventTime_, ModulePath) : 0
#define EventWriteDriverLoad_AssumeEnabled(EventTime_, ModulePath) \
        _mcgen_TEMPLATE_FOR_DriverLoad(&JonMonProvider_Context, &DriverLoad, NULL, EventTime_, ModulePath)
#define EventWriteDriverLoad_ForContext(pContext, Activity, EventTime_, ModulePath) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DriverLoad) \
        ? _mcgen_TEMPLATE_FOR_DriverLoad(&(pContext)->Context, &DriverLoad, Activity, EventTime_, ModulePath) : 0
#define EventWriteDriverLoad_ForContextAssumeEnabled(pContext, EventTime_, ModulePath) \
        _mcgen_TEMPLATE_FOR_DriverLoad(&_mcgen_CheckContextType_JonMon(pContext)->Context, &DriverLoad, NULL, EventTime_, ModulePath)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DriverLoad _mcgen_PASTE2(McTemplateK0mz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "DPAPI"
//
#define EventEnabledDPAPI() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledDPAPI_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "DPAPI"
//
#define EventWriteDPAPI(Activity, EventTime_, Operation, DataDescription, SourceProcessId, Flags, ProtectionFlags) \
        MCGEN_EVENT_ENABLED(DPAPI) \
        ? _mcgen_TEMPLATE_FOR_DPAPI(&JonMonProvider_Context, &DPAPI, Activity, EventTime_, Operation, DataDescription, SourceProcessId, Flags, ProtectionFlags) : 0
#define EventWriteDPAPI_AssumeEnabled(EventTime_, Operation, DataDescription, SourceProcessId, Flags, ProtectionFlags) \
        _mcgen_TEMPLATE_FOR_DPAPI(&JonMonProvider_Context, &DPAPI, NULL, EventTime_, Operation, DataDescription, SourceProcessId, Flags, ProtectionFlags)
#define EventWriteDPAPI_ForContext(pContext, Activity, EventTime_, Operation, DataDescription, SourceProcessId, Flags, ProtectionFlags) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, DPAPI) \
        ? _mcgen_TEMPLATE_FOR_DPAPI(&(pContext)->Context, &DPAPI, Activity, EventTime_, Operation, DataDescription, SourceProcessId, Flags, ProtectionFlags) : 0
#define EventWriteDPAPI_ForContextAssumeEnabled(pContext, EventTime_, Operation, DataDescription, SourceProcessId, Flags, ProtectionFlags) \
        _mcgen_TEMPLATE_FOR_DPAPI(&_mcgen_CheckContextType_JonMon(pContext)->Context, &DPAPI, NULL, EventTime_, Operation, DataDescription, SourceProcessId, Flags, ProtectionFlags)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_DPAPI _mcgen_PASTE2(McTemplateK0mzzqqq_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TIWriteProcessMemory"
//
#define EventEnabledTIWriteProcessMemory() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledTIWriteProcessMemory_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "TIWriteProcessMemory"
//
#define EventWriteTIWriteProcessMemory(Activity, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) \
        MCGEN_EVENT_ENABLED(TIWriteProcessMemory) \
        ? _mcgen_TEMPLATE_FOR_TIWriteProcessMemory(&JonMonProvider_Context, &TIWriteProcessMemory, Activity, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) : 0
#define EventWriteTIWriteProcessMemory_AssumeEnabled(EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) \
        _mcgen_TEMPLATE_FOR_TIWriteProcessMemory(&JonMonProvider_Context, &TIWriteProcessMemory, NULL, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack)
#define EventWriteTIWriteProcessMemory_ForContext(pContext, Activity, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TIWriteProcessMemory) \
        ? _mcgen_TEMPLATE_FOR_TIWriteProcessMemory(&(pContext)->Context, &TIWriteProcessMemory, Activity, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) : 0
#define EventWriteTIWriteProcessMemory_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) \
        _mcgen_TEMPLATE_FOR_TIWriteProcessMemory(&_mcgen_CheckContextType_JonMon(pContext)->Context, &TIWriteProcessMemory, NULL, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TIWriteProcessMemory _mcgen_PASTE2(McTemplateK0mqqzqzxxz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TIReadProcessMemory"
//
#define EventEnabledTIReadProcessMemory() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledTIReadProcessMemory_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "TIReadProcessMemory"
//
#define EventWriteTIReadProcessMemory(Activity, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) \
        MCGEN_EVENT_ENABLED(TIReadProcessMemory) \
        ? _mcgen_TEMPLATE_FOR_TIReadProcessMemory(&JonMonProvider_Context, &TIReadProcessMemory, Activity, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) : 0
#define EventWriteTIReadProcessMemory_AssumeEnabled(EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) \
        _mcgen_TEMPLATE_FOR_TIReadProcessMemory(&JonMonProvider_Context, &TIReadProcessMemory, NULL, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack)
#define EventWriteTIReadProcessMemory_ForContext(pContext, Activity, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TIReadProcessMemory) \
        ? _mcgen_TEMPLATE_FOR_TIReadProcessMemory(&(pContext)->Context, &TIReadProcessMemory, Activity, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) : 0
#define EventWriteTIReadProcessMemory_ForContextAssumeEnabled(pContext, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack) \
        _mcgen_TEMPLATE_FOR_TIReadProcessMemory(&_mcgen_CheckContextType_JonMon(pContext)->Context, &TIReadProcessMemory, NULL, EventTime_, SourceProcessId, SourceThreadId, SourceProcessFilePath, TargetProcessId, TargetProcessFilePath, SourceProcessStartKey, TargetProcessStartKey, CallStack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TIReadProcessMemory _mcgen_PASTE2(McTemplateK0mqqzqzxxz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "ThreadTokenImpersonation"
//
#define EventEnabledThreadTokenImpersonation() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledThreadTokenImpersonation_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "ThreadTokenImpersonation"
//
#define EventWriteThreadTokenImpersonation(Activity, EventTime_, ProcessId, ImpersonatedThreadId, ThreadUserName, ThreadIntegrityLevel, ProcessUserName, ProcessIntegrityLevel) \
        MCGEN_EVENT_ENABLED(ThreadTokenImpersonation) \
        ? _mcgen_TEMPLATE_FOR_ThreadTokenImpersonation(&JonMonProvider_Context, &ThreadTokenImpersonation, Activity, EventTime_, ProcessId, ImpersonatedThreadId, ThreadUserName, ThreadIntegrityLevel, ProcessUserName, ProcessIntegrityLevel) : 0
#define EventWriteThreadTokenImpersonation_AssumeEnabled(EventTime_, ProcessId, ImpersonatedThreadId, ThreadUserName, ThreadIntegrityLevel, ProcessUserName, ProcessIntegrityLevel) \
        _mcgen_TEMPLATE_FOR_ThreadTokenImpersonation(&JonMonProvider_Context, &ThreadTokenImpersonation, NULL, EventTime_, ProcessId, ImpersonatedThreadId, ThreadUserName, ThreadIntegrityLevel, ProcessUserName, ProcessIntegrityLevel)
#define EventWriteThreadTokenImpersonation_ForContext(pContext, Activity, EventTime_, ProcessId, ImpersonatedThreadId, ThreadUserName, ThreadIntegrityLevel, ProcessUserName, ProcessIntegrityLevel) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, ThreadTokenImpersonation) \
        ? _mcgen_TEMPLATE_FOR_ThreadTokenImpersonation(&(pContext)->Context, &ThreadTokenImpersonation, Activity, EventTime_, ProcessId, ImpersonatedThreadId, ThreadUserName, ThreadIntegrityLevel, ProcessUserName, ProcessIntegrityLevel) : 0
#define EventWriteThreadTokenImpersonation_ForContextAssumeEnabled(pContext, EventTime_, ProcessId, ImpersonatedThreadId, ThreadUserName, ThreadIntegrityLevel, ProcessUserName, ProcessIntegrityLevel) \
        _mcgen_TEMPLATE_FOR_ThreadTokenImpersonation(&_mcgen_CheckContextType_JonMon(pContext)->Context, &ThreadTokenImpersonation, NULL, EventTime_, ProcessId, ImpersonatedThreadId, ThreadUserName, ThreadIntegrityLevel, ProcessUserName, ProcessIntegrityLevel)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_ThreadTokenImpersonation _mcgen_PASTE2(McTemplateK0mqqzzzz_, MCGEN_EVENTWRITETRANSFER)

//
// Enablement check macro for event "TIRemoteAllocateVirtualMemory"
//
#define EventEnabledTIRemoteAllocateVirtualMemory() _mcgen_EVENT_BIT_SET(JonMonEnableBits, 0)
#define EventEnabledTIRemoteAllocateVirtualMemory_ForContext(pContext) _mcgen_EVENT_BIT_SET(_mcgen_CheckContextType_JonMon(pContext)->EnableBits, 0)

//
// Event write macros for event "TIRemoteAllocateVirtualMemory"
//
#define EventWriteTIRemoteAllocateVirtualMemory(Activity, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, BaseAddress, SourceProcessFilePath, TargetProcessFilePath, CallStack) \
        MCGEN_EVENT_ENABLED(TIRemoteAllocateVirtualMemory) \
        ? _mcgen_TEMPLATE_FOR_TIRemoteAllocateVirtualMemory(&JonMonProvider_Context, &TIRemoteAllocateVirtualMemory, Activity, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, BaseAddress, SourceProcessFilePath, TargetProcessFilePath, CallStack) : 0
#define EventWriteTIRemoteAllocateVirtualMemory_AssumeEnabled(EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, BaseAddress, SourceProcessFilePath, TargetProcessFilePath, CallStack) \
        _mcgen_TEMPLATE_FOR_TIRemoteAllocateVirtualMemory(&JonMonProvider_Context, &TIRemoteAllocateVirtualMemory, NULL, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, BaseAddress, SourceProcessFilePath, TargetProcessFilePath, CallStack)
#define EventWriteTIRemoteAllocateVirtualMemory_ForContext(pContext, Activity, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, BaseAddress, SourceProcessFilePath, TargetProcessFilePath, CallStack) \
        MCGEN_EVENT_ENABLED_FORCONTEXT(pContext, TIRemoteAllocateVirtualMemory) \
        ? _mcgen_TEMPLATE_FOR_TIRemoteAllocateVirtualMemory(&(pContext)->Context, &TIRemoteAllocateVirtualMemory, Activity, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, BaseAddress, SourceProcessFilePath, TargetProcessFilePath, CallStack) : 0
#define EventWriteTIRemoteAllocateVirtualMemory_ForContextAssumeEnabled(pContext, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, BaseAddress, SourceProcessFilePath, TargetProcessFilePath, CallStack) \
        _mcgen_TEMPLATE_FOR_TIRemoteAllocateVirtualMemory(&_mcgen_CheckContextType_JonMon(pContext)->Context, &TIRemoteAllocateVirtualMemory, NULL, EventTime_, SourceThreadId, SourceProcessId, TargetProcessId, SourceProcessStartKey, TargetProcessStartKey, OriginalProcessId, BaseAddress, SourceProcessFilePath, TargetProcessFilePath, CallStack)

// This macro is for use by MC-generated code and should not be used directly.
#define _mcgen_TEMPLATE_FOR_TIRemoteAllocateVirtualMemory _mcgen_PASTE2(McTemplateK0mqqqxxqpzzz_, MCGEN_EVENTWRITETRANSFER)

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// MCGEN_DISABLE_PROVIDER_CODE_GENERATION macro:
// Define this macro to have the compiler skip the generated functions in this
// header.
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Template Functions
//

//
// Function for template "EID2" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mdxxzxxxzzq_def
#define McTemplateK0mdxxzxxxzzq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mdxxzxxxzzq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_ const signed int  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const unsigned __int64  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_ const unsigned int  _Arg10
    )
{
#define McTemplateK0mdxxzxxxzzq_ARGCOUNT 11

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mdxxzxxxzzq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mdxxzxxxzzq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mdxxzxxxzzq_def

//
// Function for template "EID26" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mqqqqxxqppzzz_def
#define McTemplateK0mqqqqxxqppzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mqqqqxxqppzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const unsigned int  _Arg7,
    _In_opt_ const void*  _Arg8,
    _In_opt_ const void*  _Arg9,
    _In_opt_ PCWSTR  _Arg10,
    _In_opt_ PCWSTR  _Arg11,
    _In_opt_ PCWSTR  _Arg12
    )
{
#define McTemplateK0mqqqqxxqppzzz_ARGCOUNT 13

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mqqqqxxqppzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const void*)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const void*)  );

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : L"NULL",
                        (_Arg10 != NULL) ? (ULONG)((wcslen(_Arg10) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[12],
                        (_Arg11 != NULL) ? _Arg11 : L"NULL",
                        (_Arg11 != NULL) ? (ULONG)((wcslen(_Arg11) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[13],
                        (_Arg12 != NULL) ? _Arg12 : L"NULL",
                        (_Arg12 != NULL) ? (ULONG)((wcslen(_Arg12) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mqqqqxxqppzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mqqqqxxqppzzz_def

//
// Function for template "EID32" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mqqqxxqpzzz_def
#define McTemplateK0mqqqxxqpzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mqqqxxqpzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_opt_ const void*  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_opt_ PCWSTR  _Arg10
    )
{
#define McTemplateK0mqqqxxqpzzz_ARGCOUNT 11

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mqqqxxqpzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const void*)  );

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : L"NULL",
                        (_Arg10 != NULL) ? (ULONG)((wcslen(_Arg10) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mqqqxxqpzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mqqqxxqpzzz_def

//
// Function for template "EID29" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mqqzqzxxz_def
#define McTemplateK0mqqzqzxxz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mqqzqzxxz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const unsigned __int64  _Arg7,
    _In_opt_ PCWSTR  _Arg8
    )
{
#define McTemplateK0mqqzqzxxz_ARGCOUNT 9

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mqqzqzxxz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mqqzqzxxz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mqqzqzxxz_def

//
// Function for template "EID31" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mqqzzzz_def
#define McTemplateK0mqqzzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mqqzzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6
    )
{
#define McTemplateK0mqqzzzz_ARGCOUNT 7

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mqqzzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mqqzzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mqqzzzz_def

//
// Function for template "EID16" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mqzqq_def
#define McTemplateK0mqzqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mqzqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4
    )
{
#define McTemplateK0mqzqq_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mqzqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mqzqq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mqzqq_def

//
// Function for template "EID13" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mqzzhhzzz_def
#define McTemplateK0mqzzhhzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mqzzhhzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_ const unsigned short  _Arg4,
    _In_ const unsigned short  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8
    )
{
#define McTemplateK0mqzzhhzzz_ARGCOUNT 9

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mqzzhhzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mqzzhhzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mqzzhhzzz_def

//
// Function for template "EID15" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mqzzzh_def
#define McTemplateK0mqzzzh_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mqzzzh_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_ const unsigned int  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_ const unsigned short  _Arg5
    )
{
#define McTemplateK0mqzzzh_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mqzzzh_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],&_Arg1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned short)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mqzzzh_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mqzzzh_def

//
// Function for template "EID27" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mz_def
#define McTemplateK0mz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1
    )
{
#define McTemplateK0mz_ARGCOUNT 2

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mz_def

//
// Function for template "EID11" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzqqqzzzzzzz_def
#define McTemplateK0mzqqqzzzzzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzqqqzzzzzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned int  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_opt_ PCWSTR  _Arg10,
    _In_opt_ PCWSTR  _Arg11
    )
{
#define McTemplateK0mzqqqzzzzzzz_ARGCOUNT 12

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzqqqzzzzzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : L"NULL",
                        (_Arg10 != NULL) ? (ULONG)((wcslen(_Arg10) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[12],
                        (_Arg11 != NULL) ? _Arg11 : L"NULL",
                        (_Arg11 != NULL) ? (ULONG)((wcslen(_Arg11) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzqqqzzzzzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzqqqzzzzzzz_def

//
// Function for template "EID5" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzxxxzdzq_def
#define McTemplateK0mzxxxzdzq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzxxxzdzq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const signed int  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_ const unsigned int  _Arg8
    )
{
#define McTemplateK0mzxxxzdzq_ARGCOUNT 9

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzxxxzdzq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzxxxzdzq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzxxxzdzq_def

//
// Function for template "EID10" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzxxxzqzz_def
#define McTemplateK0mzxxxzqzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzxxxzqzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8
    )
{
#define McTemplateK0mzxxxzqzz_ARGCOUNT 9

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzxxxzqzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzxxxzqzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzxxxzqzz_def

//
// Function for template "EID24" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzxxxzqzzdd_def
#define McTemplateK0mzxxxzqzzdd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzxxxzqzzdd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const signed int  _Arg9,
    _In_ const signed int  _Arg10
    )
{
#define McTemplateK0mzxxxzqzzdd_ARGCOUNT 11

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzxxxzqzzdd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const signed int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzxxxzqzzdd_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzxxxzqzzdd_def

//
// Function for template "EID23" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzxxxzqzztd_def
#define McTemplateK0mzxxxzqzztd_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzxxxzqzztd_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const signed int  _Arg9,
    _In_ const signed int  _Arg10
    )
{
#define McTemplateK0mzxxxzqzztd_ARGCOUNT 11

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzxxxzqzztd_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const signed int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzxxxzqzztd_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzxxxzqzztd_def

//
// Function for template "EID18" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzxxxzqzzxxxzqz_def
#define McTemplateK0mzxxxzqzzxxxzqz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzxxxzqzzxxxzqz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned int  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const unsigned __int64  _Arg9,
    _In_ const unsigned __int64  _Arg10,
    _In_ const unsigned __int64  _Arg11,
    _In_opt_ PCWSTR  _Arg12,
    _In_ const unsigned int  _Arg13,
    _In_opt_ PCWSTR  _Arg14
    )
{
#define McTemplateK0mzxxxzqzzxxxzqz_ARGCOUNT 15

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzxxxzqzzxxxzqz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[13],
                        (_Arg12 != NULL) ? _Arg12 : L"NULL",
                        (_Arg12 != NULL) ? (ULONG)((wcslen(_Arg12) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[14],&_Arg13, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[15],
                        (_Arg14 != NULL) ? _Arg14 : L"NULL",
                        (_Arg14 != NULL) ? (ULONG)((wcslen(_Arg14) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzxxxzqzzxxxzqz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzxxxzqzzxxxzqz_def

//
// Function for template "EID4" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzxxxzzq_def
#define McTemplateK0mzxxxzzq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzxxxzzq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_ const unsigned int  _Arg7
    )
{
#define McTemplateK0mzxxxzzq_ARGCOUNT 8

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzxxxzzq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzxxxzzq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzxxxzzq_def

//
// Function for template "EID7" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzxxxzzzzzq_def
#define McTemplateK0mzxxxzzzzzq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzxxxzzzzzq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_opt_ PCWSTR  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_ const unsigned int  _Arg10
    )
{
#define McTemplateK0mzxxxzzzzzq_ARGCOUNT 11

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzxxxzzzzzq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],
                        (_Arg7 != NULL) ? _Arg7 : L"NULL",
                        (_Arg7 != NULL) ? (ULONG)((wcslen(_Arg7) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],&_Arg10, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzxxxzzzzzq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzxxxzzzzzq_def

//
// Function for template "EID9" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzxxzx_def
#define McTemplateK0mzxxzx_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzxxzx_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_ const unsigned __int64  _Arg5
    )
{
#define McTemplateK0mzxxzx_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzxxzx_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzxxzx_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzxxzx_def

//
// Function for template "EID17" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzxxzzxdzzzz_def
#define McTemplateK0mzxxzzxdzzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzxxzzxdzzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_ const unsigned __int64  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_opt_ PCWSTR  _Arg4,
    _In_opt_ PCWSTR  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const signed int  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_opt_ PCWSTR  _Arg9,
    _In_opt_ PCWSTR  _Arg10,
    _In_opt_ PCWSTR  _Arg11
    )
{
#define McTemplateK0mzxxzzxdzzzz_ARGCOUNT 12

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzxxzzxdzzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],&_Arg2, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[6],
                        (_Arg5 != NULL) ? _Arg5 : L"NULL",
                        (_Arg5 != NULL) ? (ULONG)((wcslen(_Arg5) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],
                        (_Arg9 != NULL) ? _Arg9 : L"NULL",
                        (_Arg9 != NULL) ? (ULONG)((wcslen(_Arg9) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : L"NULL",
                        (_Arg10 != NULL) ? (ULONG)((wcslen(_Arg10) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[12],
                        (_Arg11 != NULL) ? _Arg11 : L"NULL",
                        (_Arg11 != NULL) ? (ULONG)((wcslen(_Arg11) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzxxzzxdzzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzxxzzxdzzzz_def

//
// Function for template "EID19" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzzq_def
#define McTemplateK0mzzq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzzq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned int  _Arg3
    )
{
#define McTemplateK0mzzq_ARGCOUNT 4

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzzq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzzq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzzq_def

//
// Function for template "EID28" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzzqqq_def
#define McTemplateK0mzzqqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzzqqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned int  _Arg3,
    _In_ const unsigned int  _Arg4,
    _In_ const unsigned int  _Arg5
    )
{
#define McTemplateK0mzzqqq_ARGCOUNT 6

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzzqqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzzqqq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzzqqq_def

//
// Function for template "EID8" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzzxxxxxzxzzzzqqq_def
#define McTemplateK0mzzxxxxxzxzzzzqqq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzzxxxxxzxzzzzqqq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_ const unsigned __int64  _Arg6,
    _In_ const unsigned __int64  _Arg7,
    _In_opt_ PCWSTR  _Arg8,
    _In_ const unsigned __int64  _Arg9,
    _In_opt_ PCWSTR  _Arg10,
    _In_opt_ PCWSTR  _Arg11,
    _In_opt_ PCWSTR  _Arg12,
    _In_opt_ PCWSTR  _Arg13,
    _In_ const unsigned int  _Arg14,
    _In_ const unsigned int  _Arg15,
    _In_ const unsigned int  _Arg16
    )
{
#define McTemplateK0mzzxxxxxzxzzzzqqq_ARGCOUNT 17

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzzxxxxxzxzzzzqqq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],&_Arg6, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[9],
                        (_Arg8 != NULL) ? _Arg8 : L"NULL",
                        (_Arg8 != NULL) ? (ULONG)((wcslen(_Arg8) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : L"NULL",
                        (_Arg10 != NULL) ? (ULONG)((wcslen(_Arg10) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[12],
                        (_Arg11 != NULL) ? _Arg11 : L"NULL",
                        (_Arg11 != NULL) ? (ULONG)((wcslen(_Arg11) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[13],
                        (_Arg12 != NULL) ? _Arg12 : L"NULL",
                        (_Arg12 != NULL) ? (ULONG)((wcslen(_Arg12) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[14],
                        (_Arg13 != NULL) ? _Arg13 : L"NULL",
                        (_Arg13 != NULL) ? (ULONG)((wcslen(_Arg13) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[15],&_Arg14, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[16],&_Arg15, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[17],&_Arg16, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzzxxxxxzxzzzzqqq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzzxxxxxzxzzzzqqq_def

//
// Function for template "EID1" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzzxxxzqxxzxzq_def
#define McTemplateK0mzzxxxzqxxzxzq_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzzxxxzqxxzxzq_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_ const unsigned __int64  _Arg3,
    _In_ const unsigned __int64  _Arg4,
    _In_ const unsigned __int64  _Arg5,
    _In_opt_ PCWSTR  _Arg6,
    _In_ const unsigned int  _Arg7,
    _In_ const unsigned __int64  _Arg8,
    _In_ const unsigned __int64  _Arg9,
    _In_opt_ PCWSTR  _Arg10,
    _In_ const unsigned __int64  _Arg11,
    _In_opt_ PCWSTR  _Arg12,
    _In_ const unsigned int  _Arg13
    )
{
#define McTemplateK0mzzxxxzqxxzxzq_ARGCOUNT 14

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzzxxxzqxxzxzq_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],&_Arg3, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[5],&_Arg4, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[6],&_Arg5, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[7],
                        (_Arg6 != NULL) ? _Arg6 : L"NULL",
                        (_Arg6 != NULL) ? (ULONG)((wcslen(_Arg6) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[8],&_Arg7, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[9],&_Arg8, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[10],&_Arg9, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[11],
                        (_Arg10 != NULL) ? _Arg10 : L"NULL",
                        (_Arg10 != NULL) ? (ULONG)((wcslen(_Arg10) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[12],&_Arg11, sizeof(const unsigned __int64)  );

    EventDataDescCreate(&EventData[13],
                        (_Arg12 != NULL) ? _Arg12 : L"NULL",
                        (_Arg12 != NULL) ? (ULONG)((wcslen(_Arg12) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[14],&_Arg13, sizeof(const unsigned int)  );

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzzxxxzqxxzxzq_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzzxxxzqxxzxzq_def

//
// Function for template "EID25" (and possibly others).
// This function is for use by MC-generated code and should not be used directly.
//
#ifndef McTemplateK0mzzzz_def
#define McTemplateK0mzzzz_def
ETW_INLINE
ULONG
_mcgen_PASTE2(McTemplateK0mzzzz_, MCGEN_EVENTWRITETRANSFER)(
    _In_ PMCGEN_TRACE_CONTEXT Context,
    _In_ PCEVENT_DESCRIPTOR Descriptor,
    _In_opt_ const GUID* Activity,
    _In_ const FILETIME*  _Arg0,
    _In_opt_ PCWSTR  _Arg1,
    _In_opt_ PCWSTR  _Arg2,
    _In_opt_ PCWSTR  _Arg3,
    _In_opt_ PCWSTR  _Arg4
    )
{
#define McTemplateK0mzzzz_ARGCOUNT 5

    EVENT_DATA_DESCRIPTOR EventData[McTemplateK0mzzzz_ARGCOUNT + 1];

    EventDataDescCreate(&EventData[1],_Arg0, sizeof(FILETIME)  );

    EventDataDescCreate(&EventData[2],
                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[3],
                        (_Arg2 != NULL) ? _Arg2 : L"NULL",
                        (_Arg2 != NULL) ? (ULONG)((wcslen(_Arg2) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[4],
                        (_Arg3 != NULL) ? _Arg3 : L"NULL",
                        (_Arg3 != NULL) ? (ULONG)((wcslen(_Arg3) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[5],
                        (_Arg4 != NULL) ? _Arg4 : L"NULL",
                        (_Arg4 != NULL) ? (ULONG)((wcslen(_Arg4) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return McGenEventWrite(Context, Descriptor, Activity, McTemplateK0mzzzz_ARGCOUNT + 1, EventData);
}
#endif // McTemplateK0mzzzz_def

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

#if defined(__cplusplus)
}
#endif

#define MSG_ProcessCreation_EventMessage     0xB0000001L
#define MSG_ProcessAccess_EventMessage       0xB0000002L
#define MSG_ProcessAccessDuplicated_EventMessage 0xB0000003L
#define MSG_ImageLoaded_EventMessage         0xB0000004L
#define MSG_RegistryCreateKey_EventMessage   0xB0000005L
#define MSG_RegistryDeleteKey_EventMessage   0xB0000006L
#define MSG_RegistrySetValue_EventMessage    0xB0000007L
#define MSG_ProcessReparenting_EventMessage  0xB0000008L
#define MSG_ProcessTerminate_EventMessage    0xB0000009L
#define MSG_FileRename_EventMessage          0xB000000AL
#define MSG_RPCClientCall_EventMessage       0xB000000BL
#define MSG_RPCServerCall_EventMessage       0xB000000CL
#define MSG_NetworkConnectionAccepted_EventMessage 0xB000000DL
#define MSG_RegistrySaveKey_EventMessage     0xB000000EL
#define MSG_DotNetLoad_EventMessage          0xB000000FL
#define MSG_AMSI_EventMessage                0xB0000010L
#define MSG_ImpersonationAction_EventMessage 0xB0000011L
#define MSG_RemoteThreadCreation_EventMessage 0xB0000012L
#define MSG_SchedTaskCreation_EventMessage   0xB0000013L
#define MSG_SchedTaskStarted_EventMessage    0xB0000014L
#define MSG_FileCreate_EventMessage          0xB0000015L
#define MSG_FileDelete_EventMessage          0xB0000016L
#define MSG_NamedPipeCreate_EventMessage     0xB0000017L
#define MSG_NamedPipeOpen_EventMessage       0xB0000018L
#define MSG_WMIFilterToConsumerBinding_EventMessage 0xB0000019L
#define MSG_TIQueueUserAPCEvent_EventMessage 0xB000001AL
#define MSG_DriverLoad_EventMessage          0xB000001BL
#define MSG_DPAPI_EventMessage               0xB000001CL
#define MSG_TIWriteProcessMemory_EventMessage 0xB000001DL
#define MSG_TIReadProcessMemory_EventMessage 0xB000001EL
#define MSG_ThreadTokenImpersonation_EventMessage 0xB000001FL
#define MSG_TIRemoteAllocateVirtualMemory_EventMessage 0xB0000020L
